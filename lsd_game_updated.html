<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lake Shore Driver</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=VT323&display=swap');
        
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background: #000;
            font-family: 'Segoe UI', system-ui, sans-serif;
        }
        #game-container { 
            width: 100vw; 
            height: 100vh; 
            position: fixed;
            top: 0;
            left: 0;
            z-index: 1;
        }
        
        #game-container canvas {
            display: block;
            width: 100%;
            height: 100%;
        }
        
        /* Start Screen */
        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 1000;
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #ccc; text-align: center;
            font-family: 'Courier New', monospace;
        }
        
        #start-screen.hidden { display: none; }
        
        .ascii-title {
            font-family: 'Courier New', monospace;
            white-space: pre; text-align: center;
            color: #ccc; font-size: 8px; line-height: 9px;
            margin-bottom: 50px; font-weight: bold;
            overflow-x: auto; max-width: 100%; padding: 0 20px;
        }
        
        @media (min-width: 800px) { .ascii-title { font-size: 12px; line-height: 13px; } }
        @media (min-width: 1100px) { .ascii-title { font-size: 16px; line-height: 17px; } }
        
        .btn-retro {
            background: #000; border: 2px solid #ccc; color: #ccc;
            padding: 15px 40px; font-size: 1.5rem;
            font-family: 'Courier New', monospace; font-weight: bold;
            cursor: pointer; margin-top: 20px; text-transform: uppercase;
            transition: all 0.2s;
        }
        .btn-retro:hover:not([disabled]) { background: #ccc; color: #000; }
        .btn-retro:disabled { border-color: #444; color: #444; cursor: not-allowed; }
        
        .controls-hint {
            margin-top: 3rem; display: flex; align-items: flex-end;
            justify-content: center; gap: 30px;
        }
        .key-group { display: flex; flex-direction: column; align-items: center; gap: 3px; }
        .key-row { display: flex; gap: 3px; }
        .key {
            width: 36px; height: 36px; border: 2px solid #5b5e65;
            display: flex; align-items: center; justify-content: center;
            color: #5b5e65; font-family: 'Courier New', monospace; font-size: 16px;
        }
        .key-wide { width: 80px; }
        .key-label { color: #5b5e65; font-size: 10px; margin-top: 5px; }
        
        #hud {
            position: fixed;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 30px;
            z-index: 100;
        }
        
        .hud-item {
            background: rgba(0,0,0,0.7);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            padding: 15px 25px;
            text-align: center;
            backdrop-filter: blur(10px);
        }
        
        .hud-label {
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            text-transform: uppercase;
            letter-spacing: 2px;
        }
        
        .hud-value {
            color: #fff;
            font-size: 36px;
            font-weight: bold;
        }
        
        #speed-value { color: #00ff88; }
        #boost-bar {
            width: 150px;
            height: 8px;
            background: rgba(255,255,255,0.2);
            border-radius: 4px;
            margin-top: 8px;
            overflow: hidden;
        }
        #boost-fill {
            height: 100%;
            background: linear-gradient(90deg, #ff6600, #ffaa00);
            border-radius: 4px;
            transition: width 0.1s;
        }
        
        #landmark {
            position: fixed;
            top: 30px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            border: 2px solid #ffaa00;
            border-radius: 10px;
            padding: 12px 30px;
            color: #ffaa00;
            font-size: 18px;
            font-weight: bold;
            backdrop-filter: blur(10px);
            opacity: 0;
            transition: opacity 0.5s;
        }
        
        #landmark.visible { opacity: 1; }
        
        #progress {
            position: fixed;
            top: 30px;
            right: 30px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            padding: 15px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #progress-bar {
            width: 200px;
            height: 6px;
            background: rgba(255,255,255,0.2);
            border-radius: 3px;
            overflow: hidden;
        }
        
        #progress-fill {
            height: 100%;
            background: #00ff88;
            border-radius: 3px;
            width: 0%;
        }
        
        #progress-text {
            color: rgba(255,255,255,0.8);
            font-size: 12px;
            margin-top: 5px;
            text-align: center;
        }
        
        #controls {
            position: fixed;
            bottom: 30px;
            right: 30px;
            background: rgba(0,0,0,0.7);
            border-radius: 10px;
            padding: 15px;
            color: rgba(255,255,255,0.6);
            font-size: 12px;
            backdrop-filter: blur(10px);
            z-index: 100;
        }
        
        #controls div { margin: 5px 0; }
        #controls span { color: #ffaa00; }
        
        #minimap {
            position: fixed;
            top: 100px;
            right: 30px;
            width: 180px;
            height: 180px;
            background: rgba(0,20,40,0.8);
            border: 2px solid rgba(255,255,255,0.3);
            border-radius: 10px;
            overflow: hidden;
            z-index: 100;
        }
        
        #minimap-canvas {
            width: 100%;
            height: 100%;
        }
        
        #countdown-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: transparent;
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 999;
            pointer-events: none;
        }
        
        #countdown-text {
            font-family: 'Courier New', monospace;
            font-size: 14px;
            line-height: 14px;
            font-weight: bold;
            color: #ffffff;
            white-space: pre;
            text-align: center;
            animation: countdown-enter 0.3s ease-out;
        }
        
        @keyframes countdown-enter {
            0% { transform: scale(1.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }
        
        @media (min-width: 800px) { 
            #countdown-text { font-size: 18px; line-height: 18px; } 
        }
        @media (min-width: 1100px) { 
            #countdown-text { font-size: 24px; line-height: 24px; } 
        }
        
        #timer-display {
            position: fixed;
            top: 20px;
            left: 20px;
            text-align: left;
            z-index: 100;
        }
        
        #timer-value {
            font-size: 56px;
            font-weight: normal;
            color: #fff;
            text-shadow: 2px 2px 0px #000;
            font-family: 'VT323', monospace;
            letter-spacing: 2px;
        }
        
        #best-time {
            font-size: 24px;
            color: #ffcc00;
            margin-top: 5px;
            font-family: 'VT323', monospace;
        }
        
        #finish-message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 96px;
            font-weight: normal;
            color: #00ff00;
            text-shadow: 3px 3px 0px #003300;
            z-index: 500;
            display: none;
            font-family: 'VT323', monospace;
            letter-spacing: 3px;
            text-align: center;
        }
    </style>
</head>
<body>
    <!-- Start Screen -->
    <div id="start-screen">
        <pre class="ascii-title">
██╗      █████╗ ██╗  ██╗███████╗    ███████╗██╗  ██╗ ██████╗ ██████╗ ███████╗
██║     ██╔══██╗██║ ██╔╝██╔════╝    ██╔════╝██║  ██║██╔═══██╗██╔══██╗██╔════╝
██║     ███████║█████╔╝ █████╗      ███████╗███████║██║   ██║██████╔╝█████╗  
██║     ██╔══██║██╔═██╗ ██╔══╝      ╚════██║██╔══██║██║   ██║██╔══██╗██╔══╝  
███████╗██║  ██║██║  ██╗███████╗    ███████║██║  ██║╚██████╔╝██║  ██║███████╗
╚══════╝╚═╝  ╚═╝╚═╝  ╚═╝╚══════╝    ╚══════╝╚═╝  ╚═╝ ╚═════╝ ╚═╝  ╚═╝╚══════╝
                    ██████╗ ██████╗ ██╗██╗   ██╗███████╗██████╗ 
                    ██╔══██╗██╔══██╗██║██║   ██║██╔════╝██╔══██╗
                    ██║  ██║██████╔╝██║██║   ██║█████╗  ██████╔╝
                    ██║  ██║██╔══██╗██║╚██╗ ██╔╝██╔══╝  ██╔══██╗
                    ██████╔╝██║  ██║██║ ╚████╔╝ ███████╗██║  ██║
                    ╚═════╝ ╚═╝  ╚═╝╚═╝  ╚═══╝  ╚══════╝╚═╝  ╚═╝
        </pre>
        
        <button id="start-btn" class="btn-retro" onclick="startGameFromMenu()">START ENGINE</button>
        
        <div class="controls-hint">
            <div class="key-group">
                <div class="key">W</div>
                <div class="key-row">
                    <div class="key">A</div>
                    <div class="key">S</div>
                    <div class="key">D</div>
                </div>
                <div class="key-label">DRIVE</div>
            </div>
            <div class="key-group">
                <div class="key key-wide">SHIFT</div>
                <div class="key-label">DRIFT</div>
            </div>
            <div class="key-group">
                <div class="key">E</div>
                <div class="key-label">BOOST</div>
            </div>
            <div class="key-group">
                <div class="key key-wide">SPACE</div>
                <div class="key-label">BRAKE</div>
            </div>
        </div>
    </div>
    
    <div id="game-container"></div>
    
    <div id="countdown-overlay">
        <div id="countdown-text">3</div>
    </div>
    
    <div id="timer-display">
        <div id="timer-value">0:00.00</div>
        <div id="best-time"></div>
    </div>
    
    <div id="finish-message"></div>
    
    <div id="hud">
        <div class="hud-item">
            <div class="hud-label">MPH</div>
            <div class="hud-value" id="speed-value">0</div>
        </div>
        <div class="hud-item">
            <div class="hud-label">Boost</div>
            <div id="boost-bar"><div id="boost-fill" style="width: 100%"></div></div>
        </div>
        <div class="hud-item" id="hyperdrive-indicator" style="display: none; border-color: #ff00ff; color: #ff00ff;">
            <div class="hud-label">⚡ HYPERDRIVE ⚡</div>
        </div>
    </div>
    
    <div id="landmark"></div>
    
    <div id="progress">
        <div id="progress-bar"><div id="progress-fill"></div></div>
        <div id="progress-text">Hollywood Beach → Soldier Field</div>
    </div>
    
    <div id="minimap">
        <canvas id="minimap-canvas"></canvas>
    </div>
    
    <div id="controls">
        <div><span>WASD/Arrows</span> Drive</div>
        <div><span>SHIFT</span> Drift</div>
        <div><span>E</span> Boost</div>
        <div><span>H</span> ⚡ HYPERDRIVE (10x Speed!)</div>
        <div><span>SPACE</span> Handbrake</div>
        <div><span>C</span> Change Camera</div>
        <div><span>N</span> Toggle Night</div>
        <div><span>M</span> Toggle Music</div>
        <div><span>V</span> Debug View</div>
        <div><span>R</span> Restart Race</div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/loaders/GLTFLoader.js"></script>
    <script>
// LAKE SHORE DRIVE - Real Building Data (RELATIVE TO ROAD)
// Buildings positioned relative to road centerline:
// - Negative offset = west/city side
// - Positive offset = east/lake side
const BUILDINGS = [
    {name:"Edgewater Beach Apartments",offset:-100,z:7500,width:45,height:70,depth:35,color:0xf5b5a0,emissive:0x4a2a1a,shape:"box",type:"lakefront"},
    {name:"Hollywood Towers",offset:-120,z:7800,width:35,height:95,depth:28,color:0x5a5a5a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"Malibu East",offset:-110,z:6800,width:40,height:102,depth:30,color:0x6a5a4a,emissive:0x2a1a1a,shape:"box",type:"lakefront"},
    {name:"Horizon House",offset:-105,z:6900,width:36,height:92,depth:30,color:0x6a6a7a,emissive:0x2a2a3a,shape:"box",type:"lakefront"},
    {name:"Park Tower Edgewater",offset:-100,z:6500,width:38,height:88,depth:32,color:0x4a4a5a,emissive:0x1a1a2a,shape:"box",type:"lakefront"},
    {name:"Sheridan Shores",offset:-110,z:6200,width:32,height:75,depth:26,color:0x5a4a3a,emissive:0x2a1a1a,shape:"box",type:"lakefront"},
    {name:"Lawrence House",offset:-105,z:5800,width:30,height:72,depth:26,color:0x7a6a6a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"The Claridge",offset:-100,z:5500,width:32,height:78,depth:28,color:0x6a5a4a,emissive:0x2a1a1a,shape:"box",type:"lakefront"},
    {name:"Castilian Plaza",offset:-108,z:5200,width:34,height:82,depth:29,color:0x5a5a6a,emissive:0x2a2a3a,shape:"box",type:"lakefront"},
    {name:"Pensacola Place",offset:-103,z:4500,width:36,height:85,depth:30,color:0x4a4a5a,emissive:0x2a2a3a,shape:"box",type:"lakefront"},
    {name:"Addison on the Lake",offset:-105,z:4000,width:34,height:88,depth:28,color:0x5a6a7a,emissive:0x2a3a4a,shape:"box",type:"lakefront"},
    {name:"Belmont Harbor Condos",offset:-100,z:3500,width:35,height:80,depth:28,color:0x5a5a5a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"Diversey Harbor Tower",offset:-105,z:2800,width:32,height:75,depth:26,color:0x6a6a7a,emissive:0x2a2a3a,shape:"box",type:"lakefront"},
    {name:"Fullerton Lofts",offset:-103,z:2200,width:34,height:78,depth:28,color:0x7a6a5a,emissive:0x3a2a1a,shape:"box",type:"lakefront"},
    {name:"North Avenue Beach Towers",offset:-108,z:1500,width:36,height:82,depth:30,color:0x5a5a6a,emissive:0x2a2a3a,shape:"box",type:"lakefront"},
    {name:"Oak Street Beach Residences",offset:-100,z:800,width:38,height:95,depth:32,color:0x6a6a6a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"The Drake Hotel",offset:-110,z:600,width:40,height:48,depth:30,color:0xc8b896,emissive:0x4a3a2a,shape:"box",type:"lakefront"},
    {name:"Gold Coast Plaza",offset:-103,z:550,width:36,height:85,depth:30,color:0x7a6a5a,emissive:0x3a2a1a,shape:"box",type:"lakefront"},
    {name:"999 Lake Shore Plaza",offset:-95,z:500,width:38,height:98,depth:32,color:0x4a4a4a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"1000 Lake Shore Plaza",offset:-97,z:450,width:36,height:95,depth:30,color:0x5a5a6a,emissive:0x2a2a3a,shape:"box",type:"lakefront"},
    {name:"John Hancock Center",offset:-250,z:400,width:50,height:344,depth:50,color:0x1a1a1a,emissive:0x0a0a0a,shape:"tapered",type:"landmark"},
    {name:"1100 Lake Shore Drive",offset:-93,z:350,width:40,height:105,depth:34,color:0x3a3a3a,emissive:0x1a1a1a,shape:"box",type:"lakefront"},
    {name:"1120 Lake Shore Drive",offset:-95,z:300,width:35,height:88,depth:28,color:0x5a5a5a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"1130 Lake Shore Drive",offset:-97,z:250,width:38,height:92,depth:32,color:0x4a4a5a,emissive:0x2a2a3a,shape:"box",type:"lakefront"},
    {name:"860 Lake Shore Drive (North Tower)",offset:-90,z:200,width:30,height:82,depth:22,color:0x1a1a1a,emissive:0x0a0a0a,shape:"mies-glass-box",type:"lakefront"},
    {name:"880 Lake Shore Drive (South Tower)",offset:-90,z:180,width:30,height:82,depth:22,color:0x1a1a1a,emissive:0x0a0a0a,shape:"mies-glass-box",type:"lakefront"},
    {name:"Olympia Centre",offset:-270,z:100,width:34,height:195,depth:28,color:0x6a5a4a,emissive:0x2a1a1a,shape:"box",type:"skyline"},
    {name:"1200 Lake Shore Drive",offset:-91,z:100,width:42,height:108,depth:35,color:0x6a6a6a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"1250 Lake Shore Drive",offset:-93,z:50,width:40,height:100,depth:33,color:0x5a5a6a,emissive:0x2a2a3a,shape:"box",type:"lakefront"},
    {name:"Lake Point Tower",offset:180,z:50,width:45,height:197,depth:45,color:0x2a3a4a,emissive:0x1a2a3a,shape:"curved-clover",type:"lakefront"},
    {name:"Outer Drive East",offset:-85,z:-200,width:50,height:120,depth:40,color:0x4a4a4a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"McClurg Court Center",offset:-100,z:-100,width:45,height:110,depth:38,color:0x5a5a5a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"Trump Tower Chicago",offset:-350,z:-400,width:45,height:423,depth:45,color:0xb8c5d0,emissive:0x3a4a5a,shape:"setback",type:"landmark"},
    {name:"Three Illinois Center",offset:-380,z:-550,width:38,height:133,depth:32,color:0x4a4a4a,emissive:0x2a2a2a,shape:"box",type:"skyline"},
    {name:"Aon Center",offset:-450,z:-600,width:55,height:346,depth:55,color:0xe8e8e8,emissive:0x4a4a4a,shape:"box",type:"landmark"},
    {name:"Navy Pier Ferris Wheel",offset:400,z:-600,width:60,height:65,depth:60,color:0x4a4a6a,emissive:0x2a2a4a,shape:"ferris-wheel",type:"landmark"},
    {name:"One Prudential Plaza",offset:-410,z:-620,width:36,height:198,depth:30,color:0x5a5a5a,emissive:0x2a2a2a,shape:"box",type:"skyline"},
    {name:"Two Prudential Plaza",offset:-420,z:-650,width:42,height:303,depth:42,color:0x3a3a3a,emissive:0x1a1a1a,shape:"pyramid-top",type:"landmark"},
    {name:"Blue Cross Blue Shield Tower",offset:-440,z:-680,width:38,height:241,depth:38,color:0x4a6a8a,emissive:0x1a2a3a,shape:"box",type:"landmark"},
    {name:"Aqua Tower",offset:-400,z:-700,width:40,height:262,depth:40,color:0x6a8a9a,emissive:0x2a3a4a,shape:"wavy",type:"landmark"},
    {name:"Willis Tower",offset:-900,z:-800,width:68,height:442,depth:68,color:0x0d0d0d,emissive:0x050505,shape:"bundled-tube",type:"landmark"},
    {name:"340 on the Park",offset:-105,z:-1800,width:40,height:125,depth:35,color:0x4a5a6a,emissive:0x2a3a4a,shape:"box",type:"lakefront"},
    {name:"Museum Park Tower",offset:-103,z:-3200,width:35,height:105,depth:30,color:0x6a7a8a,emissive:0x2a3a4a,shape:"box",type:"lakefront"},
    {name:"One Museum Park",offset:-110,z:-3500,width:38,height:115,depth:32,color:0x5a6a7a,emissive:0x2a3a4a,shape:"box",type:"lakefront"},
    {name:"Shedd Aquarium",offset:250,z:-4300,width:60,height:20,depth:60,color:0xd8d8c8,emissive:0x3a3a2a,shape:"neoclassical",type:"landmark"},
    {name:"Field Museum",offset:200,z:-4500,width:80,height:25,depth:50,color:0xe8e8d8,emissive:0x4a4a3a,shape:"neoclassical",type:"landmark"},
    {name:"Adler Planetarium",offset:350,z:-4600,width:40,height:18,depth:40,color:0xc8c8b8,emissive:0x3a3a2a,shape:"dome",type:"landmark"},
    {name:"Burnham Harbor Towers",offset:-100,z:-5500,width:38,height:88,depth:32,color:0x5a5a5a,emissive:0x2a2a2a,shape:"box",type:"lakefront"},
    {name:"Soldier Field",offset:150,z:-6800,width:120,height:35,depth:90,color:0x3a3a3a,emissive:0x1a1a1a,shape:"stadium",type:"landmark"}
];
    </script>
    <script>
// ============================================
// LAKE SHORE DRIVE - 965 REAL OSM COORDINATES
// ============================================
const LSD_CENTERLINE = [
    {x:1467.04,y:-7909.12},{x:1455.67,y:-7865.56},{x:1420.79,y:-7737},{x:1441.76,y:-7725.7},{x:1436.57,y:-7706.31},
    {x:1407.01,y:-7584.19},{x:1375.46,y:-7579.97},{x:1354.36,y:-7510.13},{x:1375.74,y:-7452.1},{x:1320.81,y:-7402.04},
    {x:1342.36,y:-7314.85},{x:1291.26,y:-7308.62},{x:1317.92,y:-7207.21},{x:1248.85,y:-7166.07},{x:1223.35,y:-7091.89},
    {x:1286.11,y:-7075.83},{x:1207.77,y:-7046.67},{x:1273.43,y:-7025.88},{x:1256.28,y:-6972.62},{x:1178.29,y:-6962.43},
    {x:1169.22,y:-6938.67},{x:1242,y:-6936.48},{x:1161.81,y:-6918.42},{x:1207.82,y:-6866.45},{x:1205.17,y:-6856.92},
    {x:1140.85,y:-6850.48},{x:1193.29,y:-6831.56},{x:1157.69,y:-6765.07},{x:1109.42,y:-6746.01},{x:1132.21,y:-6706.07},
    {x:1092.11,y:-6689.79},{x:1111.03,y:-6647.8},{x:1044.41,y:-6532.39},{x:1049.78,y:-6481.97},{x:1003.78,y:-6420.85},
    {x:1023.77,y:-6413.37},{x:995.9,y:-6399.11},{x:1015.4,y:-6391.86},{x:953.68,y:-6278.12},{x:972.21,y:-6271.71},
    {x:947.21,y:-6259.5},{x:965.61,y:-6253.06},{x:944.31,y:-6188.95},{x:919.96,y:-6176.95},{x:934.02,y:-6159.7},
    {x:929.46,y:-6146.65},{x:889.75,y:-6083.04},{x:872.59,y:-6029.66},{x:884.74,y:-6000.61},{x:870.64,y:-5946.72},
    {x:844.36,y:-5933.31},{x:861.68,y:-5905.78},{x:832.79,y:-5884.71},{x:855,y:-5875.95},{x:816.54,y:-5812.42},
    {x:842.66,y:-5809.74},{x:839.15,y:-5791.76},{x:803.66,y:-5751.75},{x:813.87,y:-5629.39},{x:781.5,y:-5614.73},
    {x:771.96,y:-5555.6},{x:768.47,y:-5532.68},{x:796.49,y:-5519.63},{x:766.29,y:-5508.53},{x:794.84,y:-5504.94},
    {x:766.36,y:-5492.86},{x:794.51,y:-5489.94},{x:794.49,y:-5477.8},{x:767.69,y:-5473.38},{x:795.51,y:-5464.15},
    {x:769.74,y:-5458.2},{x:796.81,y:-5454.13},{x:773.26,y:-5441.99},{x:801.14,y:-5431.43},{x:777.64,y:-5425.37},
    {x:807.75,y:-5409.03},{x:783.48,y:-5408.34},{x:813.98,y:-5392.5},{x:818.73,y:-5382.41},{x:795.7,y:-5381.29},
    {x:828.14,y:-5364.63},{x:813.58,y:-5352.57},{x:836.66,y:-5351.98},{x:826.51,y:-5333.51},{x:852.25,y:-5296.66},
    {x:882.4,y:-5252.76},{x:903.12,y:-5222.84},{x:936.89,y:-5210.25},{x:920.56,y:-5198.1},{x:948.32,y:-5191.57},
    {x:934.6,y:-5175.67},{x:958.84,y:-5171.45},{x:941.56,y:-5160.34},{x:966.85,y:-5152.36},{x:947.72,y:-5145.05},
    {x:973.27,y:-5131.27},{x:953.13,y:-5126.44},{x:977.81,y:-5111.96},{x:956.78,y:-5110.77},{x:959.14,y:-5096.95},
    {x:980.47,y:-5093.15},{x:960.25,y:-5082.5},{x:981.7,y:-5066.89},{x:961.2,y:-5066.17},{x:961.03,y:-5053.18},
    {x:959.94,y:-4974.96},{x:978.2,y:-4889.24},{x:957.58,y:-4849},{x:977.4,y:-4848.6},{x:956.88,y:-4797.24},
    {x:975.69,y:-4735.29},{x:955.63,y:-4734.59},{x:954.38,y:-4709.24},{x:975.3,y:-4709.14},{x:975.3,y:-4692.46},
    {x:953.29,y:-4692.27},{x:975.25,y:-4689.79},{x:953.22,y:-4687.8},{x:974.94,y:-4674.72},{x:951.92,y:-4595.43},
    {x:948.94,y:-4431.74},{x:970.57,y:-4431.45},{x:948.68,y:-4412.31},{x:970,y:-4411.83},{x:968.72,y:-4323.61},
    {x:946.1,y:-4244.45},{x:965.93,y:-4156.2},{x:944.12,y:-4137.22},{x:965.65,y:-4136.99},{x:965.23,y:-4123.74},
    {x:943.95,y:-4122.72},{x:943.84,y:-4117.69},{x:941.5,y:-4008.02},{x:962.36,y:-3974.29},{x:941.15,y:-3932.07},
    {x:961.21,y:-3872.71},{x:938.85,y:-3855.21},{x:960.56,y:-3854.73},{x:938.85,y:-3841.5},{x:960.33,y:-3841.32},
    {x:938.94,y:-3837.78},{x:939.68,y:-3806.9},{x:961.07,y:-3804.09},{x:940.06,y:-3790.5},{x:962.69,y:-3783.2},
    {x:940.62,y:-3774.74},{x:964.95,y:-3766.48},{x:943.24,y:-3754.88},{x:966.95,y:-3754.37},{x:970.17,y:-3742.81},
    {x:946.13,y:-3742.78},{x:948.34,y:-3734.3},{x:975.73,y:-3725.7},{x:954.13,y:-3716.32},{x:981.06,y:-3712.14},
    {x:984.36,y:-3705.83},{x:960.14,y:-3702.95},{x:969.17,y:-3686.38},{x:995.28,y:-3685.47},{x:978.24,y:-3672.89},
    {x:1003.69,y:-3672.72},{x:1013.02,y:-3661.08},{x:991.2,y:-3655.38},{x:1025.24,y:-3649.94},{x:1006.82,y:-3637.76},
    {x:1040.21,y:-3637.48},{x:1050.73,y:-3630.62},{x:1066.33,y:-3621.18},{x:1030.8,y:-3616.38},{x:1076.62,y:-3615.96},
    {x:1095.59,y:-3606.96},{x:1049.2,y:-3602.18},{x:1120.28,y:-3595.33},{x:1140.5,y:-3585.78},{x:1088.14,y:-3580.13},
    {x:1163.82,y:-3572.14},{x:1179.58,y:-3561.13},{x:1124.38,y:-3556.91},{x:1189.87,y:-3552.52},{x:1200.36,y:-3542.71},
    {x:1142.43,y:-3542.25},{x:1152.81,y:-3533.69},{x:1212.03,y:-3529.17},{x:1162.58,y:-3522.92},{x:1222.94,y:-3514.32},
    {x:1175.79,y:-3507.72},{x:1231.2,y:-3501.21},{x:1237.45,y:-3489.5},{x:1190.92,y:-3487.17},{x:1197.02,y:-3476.72},
    {x:1244.98,y:-3474.01},{x:1204.8,y:-3460.49},{x:1252.24,y:-3455.27},{x:1206.96,y:-3454.42},{x:1210.24,y:-3445.16},
    {x:1255.57,y:-3441.03},{x:1214.02,y:-3431.49},{x:1258.69,y:-3427.47},{x:1218.77,y:-3408.98},{x:1261.28,y:-3408.59},
    {x:1262.02,y:-3393.46},{x:1220.8,y:-3390.81},{x:1261.91,y:-3374.92},{x:1222.58,y:-3373.48},{x:1222.69,y:-3360.8},
    {x:1259.67,y:-3348.02},{x:1222.74,y:-3347.45},{x:1221.86,y:-3311.71},{x:1255.13,y:-3308},{x:1220.47,y:-3278.79},
    {x:1251.12,y:-3277.04},{x:1247.85,y:-3245.94},{x:1219.01,y:-3218.97},{x:1218.35,y:-3202.96},{x:1236.36,y:-3137.93},
    {x:1216.58,y:-3136.29},{x:1225.72,y:-3125.06},{x:1234.9,y:-3115.4},{x:1236.43,y:-3115.01},{x:1215.57,y:-3098.91},
    {x:1223.58,y:-3081.51},{x:1233.88,y:-3081.11},{x:1231.54,y:-3079.74},{x:1215.1,y:-3079.23},{x:1214.91,y:-3072.29},
    {x:1223.06,y:-3072.16},{x:1231.33,y:-3071.97},{x:1233.56,y:-3071.94},{x:1212.9,y:-2966.37},{x:1220.61,y:-2966.25},
    {x:1229.22,y:-2965.98},{x:1231.3,y:-2965.95},{x:1212.7,y:-2958.5},{x:1229.05,y:-2958.4},{x:1220.23,y:-2945.01},
    {x:1228.73,y:-2944.94},{x:1231.26,y:-2944.92},{x:1211.12,y:-2895.62},{x:1219.03,y:-2895.43},{x:1228.27,y:-2895.18},
    {x:1231.16,y:-2895.14},{x:1229.16,y:-2874.1},{x:1213.51,y:-2869.85},{x:1231.55,y:-2862.86},{x:1213.4,y:-2862.82},
    {x:1209.75,y:-2829.53},{x:1233.2,y:-2829.23},{x:1234.24,y:-2813},{x:1212.43,y:-2796.6},{x:1232.35,y:-2796.15},
    {x:1208.99,y:-2790.62},{x:1235.91,y:-2790.32},{x:1236.46,y:-2780.98},{x:1212.04,y:-2775.8},{x:1212.21,y:-2768.1},
    {x:1208.84,y:-2768.08},{x:1236.61,y:-2767.35},{x:1232.37,y:-2767.16},{x:1212.63,y:-2729.23},{x:1232.03,y:-2728.89},
    {x:1209.46,y:-2722.6},{x:1235.91,y:-2721.58},{x:1231.82,y:-2719.21},{x:1213.04,y:-2718.86},{x:1213.15,y:-2711.01},
    {x:1231.62,y:-2710.79},{x:1235.58,y:-2702.06},{x:1213.7,y:-2694.27},{x:1213.64,y:-2685.31},{x:1210.3,y:-2679.41},
    {x:1234.57,y:-2678.91},{x:1212.37,y:-2672.56},{x:1207.25,y:-2652.18},{x:1211.13,y:-2647.51},{x:1229.59,y:-2644.31},
    {x:1204.16,y:-2641.54},{x:1201.52,y:-2632.89},{x:1211.96,y:-2612.98},{x:1233.18,y:-2612.5},{x:1212.47,y:-2591.78},
    {x:1233.27,y:-2591.01},{x:1212.75,y:-2575.43},{x:1212.12,y:-2562.01},{x:1231.11,y:-2557.53},{x:1179.84,y:-2545.54},
    {x:1181.96,y:-2543.59},{x:1210.31,y:-2542.01},{x:1183.41,y:-2541.11},{x:1229.01,y:-2540.48},{x:1184.35,y:-2536.41},
    {x:1183.92,y:-2526.71},{x:1207.39,y:-2525.14},{x:1225.83,y:-2524},{x:1204.07,y:-2512.12},{x:1181.97,y:-2510.55},
    {x:1221.38,y:-2507.04},{x:1200.64,y:-2499.96},{x:1177.08,y:-2495.43},{x:1198.24,y:-2492.25},{x:1215.11,y:-2489.37},
    {x:1169.77,y:-2480.62},{x:1192.24,y:-2477.91},{x:1167.97,y:-2476.99},{x:1209.82,y:-2476.52},{x:1205.24,y:-2466.58},
    {x:1162.12,y:-2465.61},{x:1184.13,y:-2462.14},{x:1156.76,y:-2455.17},{x:1194.69,y:-2447.24},{x:1152.13,y:-2445.31},
    {x:1142.22,y:-2424.33},{x:1154.15,y:-2404.07},{x:1165.55,y:-2393.14},{x:1141.59,y:-2381.79},{x:1115.1,y:-2366.94},
    {x:1140.21,y:-2347.69},{x:1125.59,y:-2319.34},{x:1107.27,y:-2315.48},{x:1071.89,y:-2278.21},{x:1078.66,y:-2258.09},
    {x:1054.6,y:-2207.87},{x:1029.91,y:-2190.62},{x:1060.04,y:-2190.32},{x:1024.75,y:-2119.35},{x:975.34,y:-2083},
    {x:989.6,y:-2082.54},{x:1002.69,y:-2075.11},{x:926.67,y:-1989.35},{x:939.18,y:-1979.73},{x:953.39,y:-1977.06},
    {x:900.81,y:-1938.51},{x:915.74,y:-1903.39},{x:882.06,y:-1901.58},{x:868.19,y:-1809.82},{x:837.14,y:-1809.75},
    {x:833.28,y:-1769.11},{x:793.48,y:-1720.63},{x:817.05,y:-1705.88},{x:783.67,y:-1700.34},{x:775.11,y:-1682.65},
    {x:780.42,y:-1661.14},{x:762.15,y:-1655.85},{x:756.15,y:-1644.51},{x:786.76,y:-1643.37},{x:771.53,y:-1642.7},
    {x:746.49,y:-1633.4},{x:763.98,y:-1631.26},{x:778.53,y:-1628.69},{x:739.71,y:-1629.51},{x:733.27,y:-1627.29},
    {x:753.54,y:-1620.26},{x:770.65,y:-1618.59},{x:764.2,y:-1611.81},{x:740.65,y:-1610.81},{x:729.32,y:-1604.25},
    {x:755.31,y:-1603.7},{x:717.99,y:-1599.7},{x:705.88,y:-1597.26},{x:746.54,y:-1597.26},{x:690.99,y:-1595.92},
    {x:735.1,y:-1590.59},{x:722.88,y:-1585.37},{x:712.1,y:-1582.14},{x:701.33,y:-1580.03},{x:685.88,y:-1578.37},
    {x:600.57,y:-1570.92},{x:584.79,y:-1569.03},{x:570.9,y:-1566.37},{x:554.46,y:-1561.69},{x:536.8,y:-1555.58},
    {x:523.02,y:-1549.8},{x:506.36,y:-1540.81},{x:493.25,y:-1532.8},{x:480.26,y:-1523.59},{x:468.81,y:-1514.58},
    {x:458.59,y:-1505.25},{x:447.48,y:-1494.14},{x:436.04,y:-1480.92},{x:424.37,y:-1464.8},{x:416.04,y:-1451.47},
    {x:408.6,y:-1437.47},{x:402.26,y:-1423.13},{x:396.93,y:-1409.14},{x:391.6,y:-1390.69},{x:384.6,y:-1360.14},
    {x:370.83,y:-1299.13},{x:357.72,y:-1232.46},{x:345.83,y:-1167.69},{x:335.61,y:-1111.58},{x:327.74,y:-1063.06},
    {x:321.74,y:-1028.89},{x:302.4,y:-924.25},{x:286.95,y:-846.69},{x:271.95,y:-766.03},{x:266.18,y:-730.7},
    {x:263.17,y:-706.36},{x:261.36,y:-686.99},{x:260.95,y:-682.71},{x:259.4,y:-659.15},{x:258.12,y:-623.64},
    {x:253.43,y:-496.59},{x:253.01,y:-452.98},{x:251.63,y:-427.8},{x:248.71,y:-403.38},{x:244.33,y:-379.64},
    {x:235.67,y:-346.83},{x:217.7,y:-298.05},{x:203.9,y:-260.53},{x:174.87,y:-180.57},{x:152.79,y:-120.85},
    {x:117.64,y:-26.42},{x:72.66,y:85.11},{x:45.2,y:160.52},{x:14.21,y:255.55},{x:8.25,y:277.78},
    {x:-7.26,y:334.68},{x:-16.6,y:373.56},{x:-29.45,y:429.61},{x:-39.37,y:479.71},{x:-44.71,y:511.02},
    {x:-51.24,y:549.59},{x:-61.64,y:611.04},{x:-65.04,y:631.11},{x:-81.41,y:633.43},{x:-106.76,y:812.26},
    {x:-120.96,y:873.93},{x:-145.95,y:911.19},{x:-152.19,y:1008.88},{x:-189.08,y:1163.03},{x:-196.81,y:1196.07},
    {x:-223.83,y:1311.85},{x:-231.18,y:1341.85},{x:-239.88,y:1382.1},{x:-248.06,y:1421.96},{x:-252.56,y:1450.56},
    {x:-254.65,y:1469.56},{x:-255.71,y:1488.68},{x:-256.97,y:1514.8},{x:-256.97,y:1551.76},{x:-257.68,y:1644.88},
    {x:-256.71,y:1712.14},{x:-256,y:1761.26},{x:-254.41,y:1871.86},{x:-254.05,y:1905.3},{x:-253.87,y:1926.73},
    {x:-254.41,y:1961.62},{x:-255.31,y:1975.74},{x:-257.93,y:2003.08},{x:-262.08,y:2035.2},{x:-267.47,y:2066.35},
    {x:-274.35,y:2096.15},{x:-284.43,y:2131.76},{x:-295.07,y:2163.8},{x:-303.27,y:2185.35},{x:-312.47,y:2207.95},
    {x:-323.65,y:2230.36},{x:-341.93,y:2265.82},{x:-357.87,y:2294.5},{x:-370.73,y:2314.23},{x:-381.26,y:2329.38},
    {x:-399.38,y:2354.76},{x:-420.16,y:2380.87},{x:-442.13,y:2406.6},{x:-459.07,y:2423.59},{x:-477.53,y:2442.1},
    {x:-494.66,y:2457.75},{x:-535.13,y:2498.91},{x:-564.89,y:2528.12},{x:-656.07,y:2618.37},{x:-687.53,y:2651.3},
    {x:-701.46,y:2666.4},{x:-720.34,y:2689.04},{x:-739.07,y:2713.34},{x:-755.41,y:2737.11},{x:-775.82,y:2768.83},
    {x:-787.14,y:2787.31},{x:-827.85,y:2857.31},{x:-838.52,y:2877.37},{x:-850.03,y:2901.23},{x:-860.13,y:2925.23},
    {x:-880.54,y:2974.85},{x:-895.4,y:3013.04},{x:-934.88,y:3111.48},{x:-949.05,y:3097.41},{x:-968.42,y:3146.63},
    {x:-1001.18,y:3183.17},{x:-1002.01,y:3276.6},{x:-1013.06,y:3304.5},{x:-1033.22,y:3355.49},{x:-1054.47,y:3361.51},
    {x:-1064.46,y:3430.55},{x:-1110.91,y:3540.48},{x:-1158.19,y:3605.44},{x:-1181.74,y:3660.03},{x:-1185.47,y:3668.69},
    {x:-1185.58,y:3711.18},{x:-1229.53,y:3809.5},{x:-1246.84,y:3847.53},{x:-1267.41,y:3892.53},{x:-1286.98,y:3938.5},
    {x:-1292.05,y:3955.74},{x:-1296.92,y:3974.34},{x:-1301.51,y:3997.13},{x:-1304,y:4019.05},{x:-1305.4,y:4040.15},
    {x:-1305.54,y:4061.96},{x:-1303.22,y:4167.92},{x:-1300.76,y:4256.7},{x:-1301.92,y:4320.19},{x:-1303.4,y:4343.01},
    {x:-1305.21,y:4363.49},{x:-1313.87,y:4420.98},{x:-1319.38,y:4451.78},{x:-1330.78,y:4499.81},{x:-1338.59,y:4526.76},
    {x:-1376.05,y:4651.71},{x:-1386.21,y:4685.13},{x:-1395.8,y:4719.76},{x:-1404.3,y:4759.37},{x:-1411.54,y:4798.06},
    {x:-1418.72,y:4841.42},{x:-1422.2,y:4862.7},{x:-1424.61,y:4887.47},{x:-1426.71,y:4911.1},{x:-1429.31,y:4976.23},
    {x:-1430.8,y:5021.17},{x:-1433.64,y:5087.25},{x:-1440.25,y:5160.1},{x:-1442.73,y:5179.7},{x:-1472.6,y:5360.26},
    {x:-1478.69,y:5395.45},{x:-1507.51,y:5567.88},{x:-1512.52,y:5596.41},{x:-1540.53,y:5759.6},{x:-1549.17,y:5807.76},
    {x:-1572.57,y:5821.3},{x:-1578.1,y:5978.79},{x:-1583,y:6007.63},{x:-1607.36,y:6162.89},{x:-1648.33,y:6400.28},
    {x:-1658.97,y:6442.06},{x:-1687.2,y:6548.96},{x:-1711.48,y:6620.11},{x:-1742.35,y:6710.49},{x:-1772.04,y:6794.1},
    {x:-1778.9,y:6814.05},{x:-1910.71,y:7101.89},{x:-1919.57,y:7219.22},{x:-1928.91,y:7251},{x:-1939.36,y:7290.09},
    {x:-1950.48,y:7334.77},{x:-1961.08,y:7392.57},{x:-1966.65,y:7430.87},{x:-1971.93,y:7479.18},{x:-1974.33,y:7516.91},
    {x:-1976.07,y:7549.52},{x:-1976.51,y:7596.28},{x:-1976.91,y:7617.57},{x:-1977.73,y:7686.65},{x:-1978.54,y:7697.19},
    {x:-1979.17,y:7705.77},{x:-1981.89,y:7716.05},{x:-1985.03,y:7725.52},{x:-1988.97,y:7734.61},{x:-1995.32,y:7744.96},
    {x:-2001.11,y:7752.59},{x:-2007.49,y:7760.9},{x:-2015.89,y:7769.16},{x:-2026.72,y:7777.98},{x:-2041.8,y:7787.12},
    {x:-2063.45,y:7792.14},{x:-2083.79,y:7795.8},{x:-2098.93,y:7796.22}
];

// Helper function to get road X position at any Z coordinate
function getRoadXAtZ(z) {
    if (!LSD_CENTERLINE || LSD_CENTERLINE.length === 0) {
        console.error('LSD_CENTERLINE not available');
        return 0;
    }

    const y = -z; // Convert z to LSD_CENTERLINE y coordinate

    // Find the two closest points that bracket this y value
    let bestI = 0;
    let minDist = Infinity;

    for (let i = 0; i < LSD_CENTERLINE.length; i++) {
        const dist = Math.abs(LSD_CENTERLINE[i].y - y);
        if (dist < minDist) {
            minDist = dist;
            bestI = i;
        }
    }

    // Use the closest point and its neighbor for interpolation
    let i1 = bestI;
    let i2 = bestI + 1;

    // Handle edge cases
    if (i2 >= LSD_CENTERLINE.length) {
        i2 = bestI;
        i1 = bestI - 1;
    }
    if (i1 < 0) i1 = 0;

    const p1 = LSD_CENTERLINE[i1];
    const p2 = LSD_CENTERLINE[i2];

    // Simple interpolation (or just return closest point if same)
    if (p1 === p2 || Math.abs(p2.y - p1.y) < 0.01) {
        return p1.x;
    }

    const t = (y - p1.y) / (p2.y - p1.y);
    return p1.x + t * (p2.x - p1.x);
}

// Landmarks along the route (approximate y positions)
const LANDMARKS = [
    { y: -7800, name: "Hollywood Beach" },
    { y: -6500, name: "Montrose Harbor" },
    { y: -5200, name: "Belmont Harbor" },
    { y: -3600, name: "Diversey Harbor" },
    { y: -2500, name: "North Avenue Beach" },
    { y: -1600, name: "Oak Street Beach" },
    { y: -500, name: "Ohio Street Beach" },
    { y: 600, name: "Navy Pier" },
    { y: 2000, name: "Millennium Park" },
    { y: 3500, name: "Grant Park" },
    { y: 5000, name: "Museum Campus" },
    { y: 7000, name: "Soldier Field" }
];

// ============================================
// THREE.JS SETUP
// ============================================
let scene, camera, renderer;
let car, carBody;
let road, roadCurve;
let streetLights = [];
let isNight = true;

// Race state
const raceState = {
    countdown: 3,
    started: false,
    finished: false,
    startTime: 0,
    currentTime: 0,
    bestTime: null,
    frozen: true // Car frozen during countdown
};

// Car physics
const carState = {
    position: new THREE.Vector3(LSD_CENTERLINE[0].x, 0.5, -LSD_CENTERLINE[0].y),
    velocity: new THREE.Vector3(),
    rotation: Math.PI,
    angularVelocity: 0,
    speed: 0,
    boost: 100,
    isBoosting: false
};

// Input
const keys = {};

// Camera
let cameraMode = 0;
const cameraModes = ['chase', 'hood', 'cinematic'];

// Timing
let lastTime = performance.now();
let frameCount = 0;
let lastDebugTime = 0;

// Drift trail
let driftTrail = null;
const maxTrailPoints = 100;
let trailPositions = [];

// Audio engine
let audioContext = null;
let engineSound = null;
let audioStarted = false;

init();
animate();

function init() {
    // Scene
    scene = new THREE.Scene();
    scene.background = new THREE.Color(0x0a0a15);
    scene.fog = new THREE.FogExp2(0x0a0a15, 0.00015);
    
    // Camera
    camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 50000);
    
    // Renderer
    renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
    renderer.toneMapping = THREE.ACESFilmicToneMapping;
    renderer.toneMappingExposure = 1.26;
    document.getElementById('game-container').appendChild(renderer.domElement);
    
    // Lights - Increased ambient for better visibility
    const ambient = new THREE.AmbientLight(0x606080, 0.8);
    scene.add(ambient);

    // Eastern sunrise - warm sunlight rising from the east (positive X)
    const sunrise = new THREE.DirectionalLight(0xffddaa, 1.5);
    sunrise.position.set(1000, 300, 0); // East = positive X
    sunrise.castShadow = true;
    scene.add(sunrise);

    // Secondary moon light for depth
    const moon = new THREE.DirectionalLight(0x8888ff, 0.3);
    moon.position.set(-100, 200, 100);
    scene.add(moon);

    console.log('=== INITIALIZATION START ===');
    console.log('Car starting position:', LSD_CENTERLINE[0].x, 0.5, -LSD_CENTERLINE[0].y);

    // Create ground plane
    createGround();

    // Create road
    createRoad();

    // Create car
    createCar();
    console.log('Car created at:', car.position.x, car.position.y, car.position.z);
    console.log('Car has', car.children.length, 'children');

    // Create street lights
    createStreetLights();

    // Create lake
    createLake();

    // Create city with real GPS-positioned buildings (includes Navy Pier Ferris Wheel)
    createCity();

    // Add debug visualization for road alignment (press V to toggle)
    createDebugVisualization();

    console.log('=== Scene has', scene.children.length, 'objects ===');
    
    // Events
    window.addEventListener('resize', onResize);
    window.addEventListener('keydown', e => {
        keys[e.code] = true;
        e.preventDefault(); // Prevent browser shortcuts from interfering
    });
    window.addEventListener('keyup', e => {
        keys[e.code] = false;
        if (e.code === 'KeyC') cameraMode = (cameraMode + 1) % cameraModes.length;
        if (e.code === 'KeyN') toggleNight();
        if (e.code === 'KeyM') toggleMusic();
        if (e.code === 'KeyV') toggleDebugVisualization();
        if (e.code === 'KeyR' && (raceState.finished || raceState.started)) resetRace();
    });
    
    // Clear all keys when window loses focus to prevent stuck keys
    window.addEventListener('blur', () => {
        for (let key in keys) keys[key] = false;
    });
    
    // Setup minimap
    setupMinimap();
    
    // Setup drift trail
    initDriftTrail();
    
    // Setup background music
    const music = document.createElement('audio');
    music.src = 'music.mp3'; // Put your music.mp3 in the same folder as this HTML file
    music.loop = true;
    music.volume = 0.32; // Adjust volume (0.0 to 1.0)
    window.backgroundMusic = music;
    
    // Start music on first interaction (click anywhere or keypress)
    const startMusic = () => {
        if (window.backgroundMusic && window.backgroundMusic.paused) {
            window.backgroundMusic.play().catch(e => console.log('Music autoplay blocked'));
        }
    };
    document.addEventListener('click', startMusic, { once: true });
    document.addEventListener('keydown', startMusic, { once: true });

    console.log('=== INITIALIZATION COMPLETE ===');
    console.log('Camera initial position:', camera.position.x, camera.position.y, camera.position.z);
    console.log('Renderer canvas size:', renderer.domElement.width, 'x', renderer.domElement.height);
    console.log('Renderer parent element:', renderer.domElement.parentElement ? 'attached' : 'NOT ATTACHED');
}

function startGameFromMenu() {
    // Hide start screen
    document.getElementById('start-screen').classList.add('hidden');
    
    // Initialize engine audio
    if (!audioStarted) {
        initEngineSound();
        audioStarted = true;
    }
    
    // Make sure music is playing
    if (window.backgroundMusic && window.backgroundMusic.paused) {
        window.backgroundMusic.play().catch(e => console.log('Music autoplay blocked'));
    }
    
    // Start countdown
    startCountdown();
}

function initEngineSound() {
    audioContext = new (window.AudioContext || window.webkitAudioContext)();
    
    // Create engine sound components
    engineSound = {
        // Main engine oscillators (multiple for richness)
        oscillators: [],
        gains: [],
        masterGain: audioContext.createGain(),
        lowpass: audioContext.createBiquadFilter(),
        highpass: audioContext.createBiquadFilter(),
        distortion: audioContext.createWaveShaper(),
        currentGear: 1,
        rpm: 800,
        targetRpm: 800
    };
    
    // Highpass filter - gives that Porsche boxer engine character
    engineSound.highpass.type = 'highpass';
    engineSound.highpass.frequency.value = 60;
    engineSound.highpass.Q.value = 0.7;
    
    // Lowpass to tame harshness
    engineSound.lowpass.type = 'lowpass';
    engineSound.lowpass.frequency.value = 800;
    engineSound.lowpass.Q.value = 1;
    
    // Subtle distortion for growl
    engineSound.distortion.curve = makeDistortionCurve(20);
    engineSound.distortion.oversample = '2x';
    
    // Master volume
    engineSound.masterGain.gain.value = 0.3;
    
    // Create multiple oscillators for complex engine tone
    const fundamentalFreqs = [1, 2, 0.5, 1.5]; // Harmonics
    const gains = [0.4, 0.25, 0.2, 0.15];
    
    fundamentalFreqs.forEach((mult, i) => {
        const osc = audioContext.createOscillator();
        const gain = audioContext.createGain();
        
        osc.type = i === 0 ? 'sawtooth' : 'triangle';
        osc.frequency.value = 55 * mult; // Base idle frequency
        gain.gain.value = gains[i];
        
        osc.connect(gain);
        gain.connect(engineSound.highpass);
        osc.start();
        
        engineSound.oscillators.push(osc);
        engineSound.gains.push(gain);
    });
    
    // Connect chain: highpass -> distortion -> lowpass -> master -> output
    engineSound.highpass.connect(engineSound.distortion);
    engineSound.distortion.connect(engineSound.lowpass);
    engineSound.lowpass.connect(engineSound.masterGain);
    engineSound.masterGain.connect(audioContext.destination);
    
    // Tire squeal sound for drifting - use white noise for realistic screech
    const noiseBufferSize = audioContext.sampleRate * 2;
    const noiseBuffer = audioContext.createBuffer(1, noiseBufferSize, audioContext.sampleRate);
    const noiseData = noiseBuffer.getChannelData(0);
    for (let i = 0; i < noiseBufferSize; i++) {
        noiseData[i] = Math.random() * 2 - 1;
    }
    
    engineSound.squealNoise = audioContext.createBufferSource();
    engineSound.squealNoise.buffer = noiseBuffer;
    engineSound.squealNoise.loop = true;
    
    engineSound.squealGain = audioContext.createGain();
    engineSound.squealFilter = audioContext.createBiquadFilter();
    engineSound.squealFilter2 = audioContext.createBiquadFilter();
    
    // Bandpass filter centered around 3-4kHz for that tire screech
    engineSound.squealFilter.type = 'bandpass';
    engineSound.squealFilter.frequency.value = 3500;
    engineSound.squealFilter.Q.value = 2;
    
    // Second filter to shape the sound more
    engineSound.squealFilter2.type = 'highpass';
    engineSound.squealFilter2.frequency.value = 2000;
    engineSound.squealFilter2.Q.value = 1;
    
    // Start silent
    engineSound.squealGain.gain.value = 0;
    
    // Connect squeal chain: noise -> bandpass -> highpass -> gain -> output
    engineSound.squealNoise.connect(engineSound.squealFilter);
    engineSound.squealFilter.connect(engineSound.squealFilter2);
    engineSound.squealFilter2.connect(engineSound.squealGain);
    engineSound.squealGain.connect(audioContext.destination);
    
    engineSound.squealNoise.start();
}

function makeDistortionCurve(amount) {
    const samples = 44100;
    const curve = new Float32Array(samples);
    const deg = Math.PI / 180;
    for (let i = 0; i < samples; i++) {
        const x = (i * 2) / samples - 1;
        curve[i] = ((3 + amount) * x * 20 * deg) / (Math.PI + amount * Math.abs(x));
    }
    return curve;
}

function updateEngineSound() {
    if (!engineSound || !audioContext) return;
    
    const speed = Math.abs(carState.speed);
    const maxSpeed = 306;
    
    // Gear ratios - determines RPM range for each gear
    const gearRatios = [3.2, 2.1, 1.4, 1.0, 0.8, 0.65];
    const gearSpeeds = [0, 40, 80, 140, 200, 260]; // Speed at which to shift up
    
    // Determine current gear based on speed
    let gear = 1;
    for (let i = gearSpeeds.length - 1; i >= 0; i--) {
        if (speed >= gearSpeeds[i]) {
            gear = i + 1;
            break;
        }
    }
    
    // Detect gear change
    if (gear !== engineSound.currentGear) {
        engineSound.currentGear = gear;
        // Brief RPM drop on upshift
        if (gear > engineSound.currentGear) {
            engineSound.rpm *= 0.7;
        }
    }
    
    // Calculate RPM based on speed and gear
    const gearRatio = gearRatios[Math.min(gear - 1, gearRatios.length - 1)];
    const minRpm = 800;
    const maxRpm = 7000;
    
    // RPM climbs within each gear's speed range
    const gearMinSpeed = gearSpeeds[gear - 1] || 0;
    const gearMaxSpeed = gearSpeeds[gear] || maxSpeed;
    const gearProgress = (speed - gearMinSpeed) / (gearMaxSpeed - gearMinSpeed);
    
    engineSound.targetRpm = minRpm + (maxRpm - minRpm) * Math.min(gearProgress, 1) * gearRatio / gearRatios[0];
    
    // Boost pushes RPM to redline!
    if (carState.isBoosting) {
        engineSound.targetRpm = maxRpm * 1.1; // Over redline!
    }
    
    // Smooth RPM changes
    engineSound.rpm += (engineSound.targetRpm - engineSound.rpm) * 0.1;
    
    // Convert RPM to frequency (base frequency around 30-120 Hz for that boxer rumble)
    // Boost adds extra pitch
    const boostPitchMult = carState.isBoosting ? 1.3 : 1.0;
    const baseFreq = (30 + (engineSound.rpm / maxRpm) * 90) * boostPitchMult;
    
    // Update oscillator frequencies
    const fundamentalMults = [1, 2, 0.5, 1.5];
    engineSound.oscillators.forEach((osc, i) => {
        osc.frequency.setTargetAtTime(baseFreq * fundamentalMults[i], audioContext.currentTime, 0.05);
    });
    
    // Adjust filter based on RPM - opens up at higher revs
    // Boost opens filter way up for that screaming sound
    const boostFilterMult = carState.isBoosting ? 1.8 : 1.0;
    const filterFreq = (400 + (engineSound.rpm / maxRpm) * 1200) * boostFilterMult;
    engineSound.lowpass.frequency.setTargetAtTime(filterFreq, audioContext.currentTime, 0.05);
    
    // Volume based on throttle and speed
    const throttleInput = (keys['KeyW'] || keys['ArrowUp']) ? 1 : 0;
    const idleVolume = 0.15;
    const maxVolume = 0.35;
    const targetVolume = idleVolume + throttleInput * (maxVolume - idleVolume) * (0.5 + speed / maxSpeed * 0.5);
    
    // Boost adds significant volume
    const boostVolume = carState.isBoosting ? 0.084 : 0;
    
    engineSound.masterGain.gain.setTargetAtTime(targetVolume + boostVolume, audioContext.currentTime, 0.05);
    
    // Tire squeal when drifting - using filtered white noise
    if (engineSound.squealGain) {
        const isDrifting = carState.isDrifting && Math.abs(carState.visualDriftAngle) > 0.15;
        const driftIntensity = Math.min(Math.abs(carState.visualDriftAngle || 0) / 0.75, 1);
        
        // Squeal volume based on drift intensity
        const squealVolume = isDrifting ? driftIntensity * 0.045 : 0;
        engineSound.squealGain.gain.setTargetAtTime(squealVolume, audioContext.currentTime, 0.08);
        
        // Vary filter frequency based on speed for more dynamic sound
        const squealFreq = 2500 + speed * 5 + Math.sin(Date.now() * 0.008) * 300;
        engineSound.squealFilter.frequency.setTargetAtTime(squealFreq, audioContext.currentTime, 0.05);
    }
}

function createGround() {
    // Create a large map-like textured ground plane
    const groundSize = 40000; // Large enough to cover entire map area

    // Create canvas for map texture
    const canvas = document.createElement('canvas');
    canvas.width = 2048;
    canvas.height = 2048;
    const ctx = canvas.getContext('2d');

    // Lake Michigan (right/east side) - dark blue
    const lakeGradient = ctx.createLinearGradient(canvas.width * 0.65, 0, canvas.width, 0);
    lakeGradient.addColorStop(0, '#0a1a2a'); // Deep water edge
    lakeGradient.addColorStop(1, '#1a2a3a'); // Lighter water far east
    ctx.fillStyle = lakeGradient;
    ctx.fillRect(canvas.width * 0.65, 0, canvas.width * 0.35, canvas.height);

    // City (left/west side) - dark gray/brown urban
    const cityGradient = ctx.createLinearGradient(0, 0, canvas.width * 0.65, 0);
    cityGradient.addColorStop(0, '#1a1510'); // Dark urban west
    cityGradient.addColorStop(0.5, '#2a2520'); // Mid urban
    cityGradient.addColorStop(1, '#1a1a15'); // Transition to lake
    ctx.fillStyle = cityGradient;
    ctx.fillRect(0, 0, canvas.width * 0.65, canvas.height);

    // Lake Shore Drive (center vertical line) - yellow/orange road
    ctx.strokeStyle = '#3a3020';
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.62, 0);
    ctx.lineTo(canvas.width * 0.62, canvas.height);
    ctx.stroke();

    // Brighter LSD centerline
    ctx.strokeStyle = '#4a4030';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(canvas.width * 0.62, 0);
    ctx.lineTo(canvas.width * 0.62, canvas.height);
    ctx.stroke();

    // City street grid (west of LSD)
    ctx.strokeStyle = 'rgba(60, 50, 40, 0.25)';
    ctx.lineWidth = 1;

    // Vertical streets (roughly every 2 blocks)
    for (let i = 0; i < 30; i++) {
        const x = (canvas.width * 0.62) * (i / 30);
        ctx.beginPath();
        ctx.moveTo(x, 0);
        ctx.lineTo(x, canvas.height);
        ctx.stroke();
    }

    // Horizontal streets
    for (let i = 0; i < 60; i++) {
        const y = canvas.height * (i / 60);
        ctx.beginPath();
        ctx.moveTo(0, y);
        ctx.lineTo(canvas.width * 0.62, y);
        ctx.stroke();
    }

    // Parks along lakefront (green patches)
    ctx.fillStyle = 'rgba(20, 40, 20, 0.3)';
    // Grant Park area
    ctx.fillRect(canvas.width * 0.57, canvas.height * 0.45, canvas.width * 0.08, canvas.height * 0.15);
    // Lincoln Park
    ctx.fillRect(canvas.width * 0.58, canvas.height * 0.25, canvas.width * 0.07, canvas.height * 0.15);

    // Lake texture (water ripples)
    ctx.strokeStyle = 'rgba(30, 50, 70, 0.15)';
    ctx.lineWidth = 1;
    for (let i = 0; i < 40; i++) {
        const x = canvas.width * 0.65 + Math.random() * (canvas.width * 0.35);
        const y = Math.random() * canvas.height;
        const size = Math.random() * 30 + 10;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.stroke();
    }

    // Create texture from canvas
    const groundTexture = new THREE.CanvasTexture(canvas);
    groundTexture.wrapS = THREE.ClampToEdgeWrapping;
    groundTexture.wrapT = THREE.RepeatWrapping;
    groundTexture.repeat.set(1, 3); // Stretch across map, repeat north-south

    // Create ground plane
    const groundGeometry = new THREE.PlaneGeometry(groundSize, groundSize);
    const groundMaterial = new THREE.MeshStandardMaterial({
        map: groundTexture,
        roughness: 0.95,
        metalness: 0.05
    });

    const ground = new THREE.Mesh(groundGeometry, groundMaterial);
    ground.rotation.x = -Math.PI / 2; // Horizontal
    ground.position.y = -0.1; // Slightly below road
    scene.add(ground);

    console.log('Map-like ground plane created');
}

function createRoad() {
    // Create smooth curve from centerline points
    // Sample fewer points for smoother curve (skip more jagged GPS data)
    const sampleRate = 10; // Was 3, now skip more points
    const curvePoints = [];
    for (let i = 0; i < LSD_CENTERLINE.length; i += sampleRate) {
        const p = LSD_CENTERLINE[i];
        curvePoints.push(new THREE.Vector3(p.x, 0, -p.y));
    }
    
    // Use centripetal parameterization for smoother curves
    roadCurve = new THREE.CatmullRomCurve3(curvePoints, false, 'centripetal', 0.5);
    
    // Road surface - 6 lanes wide (3 each direction)
    const laneWidth = 8.0; // Extra wide lanes for arcade feel
    const roadWidth = laneWidth * 6; // 48 meters for 6 lanes
    const roadSegments = 2000;
    const roadGeometry = new THREE.BufferGeometry();
    
    const positions = [];
    const uvs = [];
    
    for (let i = 0; i <= roadSegments; i++) {
        const t = i / roadSegments;
        const point = roadCurve.getPointAt(t);
        const tangent = roadCurve.getTangentAt(t);
        
        // Get perpendicular
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
        
        const left = point.clone().add(normal.clone().multiplyScalar(roadWidth / 2));
        const right = point.clone().add(normal.clone().multiplyScalar(-roadWidth / 2));
        
        positions.push(left.x, 0.01, left.z);
        positions.push(right.x, 0.01, right.z);
        
        uvs.push(0, t * 100);
        uvs.push(1, t * 100);
    }
    
    // Create indices for triangle strip
    const indices = [];
    for (let i = 0; i < roadSegments; i++) {
        const a = i * 2;
        const b = i * 2 + 1;
        const c = i * 2 + 2;
        const d = i * 2 + 3;
        
        indices.push(a, b, c);
        indices.push(b, d, c);
    }
    
    roadGeometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
    roadGeometry.setAttribute('uv', new THREE.Float32BufferAttribute(uvs, 2));
    roadGeometry.setIndex(indices);
    roadGeometry.computeVertexNormals();
    
    const roadMaterial = new THREE.MeshStandardMaterial({
        color: 0x333333,
        roughness: 0.9,
        metalness: 0.1
    });
    
    road = new THREE.Mesh(roadGeometry, roadMaterial);
    scene.add(road);
    
    // Lane markings
    createLaneMarkings(roadWidth, laneWidth);
    
    // Road walls (with collision)
    createWalls(roadWidth);
    
    // Add jumps/ramps
    createJumps(roadWidth, laneWidth);
    
    // Add start/finish lines
    createStartFinishLines(roadWidth);
}

function createLaneMarkings(roadWidth, laneWidth) {
    const whiteMarkingMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const yellowMarkingMaterial = new THREE.MeshBasicMaterial({ color: 0xffcc00 });
    
    // Dashed white lane lines
    const dashGeometry = new THREE.PlaneGeometry(0.2, 3);
    
    // Center median - double yellow line
    const medianGeometry = new THREE.PlaneGeometry(0.15, 10);
    
    for (let i = 0; i < 600; i++) {
        const t = i / 600;
        const point = roadCurve.getPointAt(t);
        const tangent = roadCurve.getTangentAt(t);
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
        const angle = Math.atan2(tangent.x, tangent.z);
        
        // Double yellow center median
        const median1 = new THREE.Mesh(medianGeometry, yellowMarkingMaterial);
        median1.position.copy(point);
        median1.position.y = 0.02;
        median1.position.add(normal.clone().multiplyScalar(0.2));
        median1.rotation.x = -Math.PI / 2;
        median1.rotation.z = angle;
        scene.add(median1);
        
        const median2 = new THREE.Mesh(medianGeometry, yellowMarkingMaterial);
        median2.position.copy(point);
        median2.position.y = 0.02;
        median2.position.add(normal.clone().multiplyScalar(-0.2));
        median2.rotation.x = -Math.PI / 2;
        median2.rotation.z = angle;
        scene.add(median2);
        
        // White dashed lines between lanes (only every other segment for dashes)
        if (i % 2 === 0) {
            // Lanes on left side (inbound)
            for (let lane = 1; lane < 3; lane++) {
                const laneOffset = lane * laneWidth;
                const marking = new THREE.Mesh(dashGeometry, whiteMarkingMaterial);
                marking.position.copy(point);
                marking.position.y = 0.02;
                marking.position.add(normal.clone().multiplyScalar(laneOffset));
                marking.rotation.x = -Math.PI / 2;
                marking.rotation.z = angle;
                scene.add(marking);
            }
            
            // Lanes on right side (outbound)
            for (let lane = 1; lane < 3; lane++) {
                const laneOffset = -lane * laneWidth;
                const marking = new THREE.Mesh(dashGeometry, whiteMarkingMaterial);
                marking.position.copy(point);
                marking.position.y = 0.02;
                marking.position.add(normal.clone().multiplyScalar(laneOffset));
                marking.rotation.x = -Math.PI / 2;
                marking.rotation.z = angle;
                scene.add(marking);
            }
        }
    }
    
    // Solid white edge lines
    const edgeGeometry = new THREE.PlaneGeometry(0.2, 10);
    for (let i = 0; i < 600; i++) {
        const t = i / 600;
        const point = roadCurve.getPointAt(t);
        const tangent = roadCurve.getTangentAt(t);
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
        const angle = Math.atan2(tangent.x, tangent.z);
        
        // Left edge
        const leftEdge = new THREE.Mesh(edgeGeometry, whiteMarkingMaterial);
        leftEdge.position.copy(point);
        leftEdge.position.y = 0.02;
        leftEdge.position.add(normal.clone().multiplyScalar(roadWidth / 2 - 0.5));
        leftEdge.rotation.x = -Math.PI / 2;
        leftEdge.rotation.z = angle;
        scene.add(leftEdge);
        
        // Right edge
        const rightEdge = new THREE.Mesh(edgeGeometry, whiteMarkingMaterial);
        rightEdge.position.copy(point);
        rightEdge.position.y = 0.02;
        rightEdge.position.add(normal.clone().multiplyScalar(-roadWidth / 2 + 0.5));
        rightEdge.rotation.x = -Math.PI / 2;
        rightEdge.rotation.z = angle;
        scene.add(rightEdge);
    }
}

function createWalls(roadWidth) {
    // Dark grey walls at road edges - continuous
    const wallHeight = 2;
    const wallLength = 40; // Longer segments for continuous look
    const wallGeometry = new THREE.BoxGeometry(0.5, wallHeight, wallLength);
    const wallMaterial = new THREE.MeshStandardMaterial({ 
        color: 0x2a2a2a,
        roughness: 0.9,
        metalness: 0.1
    });
    
    // Store wall positions for collision detection
    window.wallSegments = [];
    
    // More segments, overlapping for continuous wall
    const numSegments = 800;
    for (let i = 0; i < numSegments; i++) {
        const t = i / numSegments;
        const point = roadCurve.getPointAt(t);
        const tangent = roadCurve.getTangentAt(t);
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
        
        // Left wall
        const leftWall = new THREE.Mesh(wallGeometry, wallMaterial);
        const leftPos = point.clone().add(normal.clone().multiplyScalar(roadWidth / 2 + 0.5));
        leftWall.position.copy(leftPos);
        leftWall.position.y = wallHeight / 2;
        leftWall.rotation.y = Math.atan2(tangent.x, tangent.z);
        scene.add(leftWall);
        
        // Right wall
        const rightWall = new THREE.Mesh(wallGeometry, wallMaterial);
        const rightPos = point.clone().add(normal.clone().multiplyScalar(-roadWidth / 2 - 0.5));
        rightWall.position.copy(rightPos);
        rightWall.position.y = wallHeight / 2;
        rightWall.rotation.y = Math.atan2(tangent.x, tangent.z);
        scene.add(rightWall);
        
        // Store for collision (fewer segments needed for collision)
        if (i % 2 === 0) {
            window.wallSegments.push({
                center: point.clone(),
                normal: normal.clone(),
                roadWidth: roadWidth
            });
        }
    }
}

function createJumps(roadWidth, laneWidth) {
    // Store jump positions for collision detection
    window.jumps = [];
    
    // Place 5 jumps at specific points along the road
    const jumpPositions = [0.15, 0.30, 0.50, 0.70, 0.85]; // t values along curve
    const jumpWidth = laneWidth * 3; // 3 lanes wide
    const jumpLength = 20; // Long enough for smooth ramp
    const jumpHeight = 2.5;
    
    jumpPositions.forEach((t, index) => {
        const point = roadCurve.getPointAt(t);
        const tangent = roadCurve.getTangentAt(t);
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
        
        // Offset jump to one side or center randomly
        const sideOffsets = [0, -laneWidth * 1.5, laneWidth * 1.5];
        const sideOffset = sideOffsets[index % 3];
        
        // Create ramp geometry - a wedge shape
        const rampGeometry = new THREE.BufferGeometry();
        
        // Vertices for a ramp (wedge)
        const vertices = new Float32Array([
            // Bottom face
            -jumpWidth/2, 0, -jumpLength/2,
            jumpWidth/2, 0, -jumpLength/2,
            jumpWidth/2, 0, jumpLength/2,
            -jumpWidth/2, 0, jumpLength/2,
            // Top face (raised at back)
            -jumpWidth/2, 0, -jumpLength/2,
            jumpWidth/2, 0, -jumpLength/2,
            jumpWidth/2, jumpHeight, jumpLength/2,
            -jumpWidth/2, jumpHeight, jumpLength/2,
        ]);
        
        const indices = [
            // Bottom
            0, 1, 2, 0, 2, 3,
            // Top (ramp surface)
            4, 6, 5, 4, 7, 6,
            // Front (flat)
            0, 4, 5, 0, 5, 1,
            // Back (raised edge)
            2, 6, 7, 2, 7, 3,
            // Left side
            0, 3, 7, 0, 7, 4,
            // Right side
            1, 5, 6, 1, 6, 2
        ];
        
        rampGeometry.setAttribute('position', new THREE.BufferAttribute(vertices, 3));
        rampGeometry.setIndex(indices);
        rampGeometry.computeVertexNormals();
        
        const rampMaterial = new THREE.MeshStandardMaterial({
            color: 0x00d4ff,
            emissive: 0x00aaff,
            emissiveIntensity: 0.5,
            roughness: 0.3,
            metalness: 0.7
        });
        
        const ramp = new THREE.Mesh(rampGeometry, rampMaterial);
        
        // Position and rotate ramp
        const rampPos = point.clone().add(normal.clone().multiplyScalar(sideOffset));
        ramp.position.copy(rampPos);
        ramp.position.y = 0.01;
        ramp.rotation.y = Math.atan2(tangent.x, tangent.z);
        
        scene.add(ramp);
        
        // Add warning stripes before jump
        const stripeGeometry = new THREE.PlaneGeometry(jumpWidth, 2);
        const stripeMaterial = new THREE.MeshBasicMaterial({ 
            color: 0xffff00,
            side: THREE.DoubleSide
        });
        
        for (let s = 1; s <= 3; s++) {
            const stripe = new THREE.Mesh(stripeGeometry, stripeMaterial);
            const stripeOffset = tangent.clone().multiplyScalar(-jumpLength/2 - s * 4);
            stripe.position.copy(rampPos).add(stripeOffset);
            stripe.position.y = 0.02;
            stripe.rotation.x = -Math.PI / 2;
            stripe.rotation.z = Math.atan2(tangent.x, tangent.z);
            scene.add(stripe);
        }
        
        // Store jump data for physics
        window.jumps.push({
            position: rampPos.clone(),
            tangent: tangent.clone(),
            normal: normal.clone(),
            width: jumpWidth,
            length: jumpLength,
            height: jumpHeight
        });
    });
}

function createStartFinishLines(roadWidth) {
    // Checkerboard pattern for start/finish lines
    const checkerSize = 2;
    const numCheckers = Math.ceil(roadWidth / checkerSize);
    
    const whiteMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
    const blackMat = new THREE.MeshBasicMaterial({ color: 0x111111 });
    const checkerGeo = new THREE.PlaneGeometry(checkerSize, checkerSize);
    
    // Start line position (t = 0.02, just after start)
    const startT = 0.02;
    const startPoint = roadCurve.getPointAt(startT);
    const startTangent = roadCurve.getTangentAt(startT);
    const startNormal = new THREE.Vector3(-startTangent.z, 0, startTangent.x).normalize();
    const startAngle = Math.atan2(startTangent.x, startTangent.z);
    
    // Store start line position for race detection
    window.startLine = {
        position: startPoint.clone(),
        tangent: startTangent.clone(),
        t: startT
    };
    
    // Create checker pattern for start
    for (let row = 0; row < 3; row++) {
        for (let i = 0; i < numCheckers; i++) {
            const checker = new THREE.Mesh(checkerGeo, (i + row) % 2 === 0 ? whiteMat : blackMat);
            const offset = (i - numCheckers / 2 + 0.5) * checkerSize;
            checker.position.copy(startPoint)
                .add(startNormal.clone().multiplyScalar(offset))
                .add(startTangent.clone().multiplyScalar(row * checkerSize - checkerSize));
            checker.position.y = 0.02;
            checker.rotation.x = -Math.PI / 2;
            checker.rotation.z = startAngle;
            scene.add(checker);
        }
    }
    
    // "START" text banner (simple boxes forming letters would be complex, so use a colored bar)
    const startBannerGeo = new THREE.PlaneGeometry(roadWidth, 4);
    const startBannerMat = new THREE.MeshBasicMaterial({ 
        color: 0x00ff00, 
        transparent: true, 
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    const startBanner = new THREE.Mesh(startBannerGeo, startBannerMat);
    startBanner.position.copy(startPoint);
    startBanner.position.y = 5;
    startBanner.rotation.y = startAngle;
    scene.add(startBanner);
    
    // Finish line position (t = 0.98, near end)
    const finishT = 0.98;
    const finishPoint = roadCurve.getPointAt(finishT);
    const finishTangent = roadCurve.getTangentAt(finishT);
    const finishNormal = new THREE.Vector3(-finishTangent.z, 0, finishTangent.x).normalize();
    const finishAngle = Math.atan2(finishTangent.x, finishTangent.z);
    
    // Store finish line position for race detection
    window.finishLine = {
        position: finishPoint.clone(),
        tangent: finishTangent.clone(),
        t: finishT
    };
    
    // Create checker pattern for finish
    for (let row = 0; row < 3; row++) {
        for (let i = 0; i < numCheckers; i++) {
            const checker = new THREE.Mesh(checkerGeo, (i + row) % 2 === 0 ? whiteMat : blackMat);
            const offset = (i - numCheckers / 2 + 0.5) * checkerSize;
            checker.position.copy(finishPoint)
                .add(finishNormal.clone().multiplyScalar(offset))
                .add(finishTangent.clone().multiplyScalar(row * checkerSize - checkerSize));
            checker.position.y = 0.02;
            checker.rotation.x = -Math.PI / 2;
            checker.rotation.z = finishAngle;
            scene.add(checker);
        }
    }
    
    // Finish banner
    const finishBannerMat = new THREE.MeshBasicMaterial({ 
        color: 0xff0000, 
        transparent: true, 
        opacity: 0.3,
        side: THREE.DoubleSide
    });
    const finishBanner = new THREE.Mesh(startBannerGeo, finishBannerMat);
    finishBanner.position.copy(finishPoint);
    finishBanner.position.y = 5;
    finishBanner.rotation.y = finishAngle;
    scene.add(finishBanner);
}

function createCar() {
    car = new THREE.Group();

    // Create fallback box car FIRST (will be replaced if model loads)
    const boxGeometry = new THREE.BoxGeometry(2, 0.8, 4.5);
    const boxMaterial = new THREE.MeshStandardMaterial({
        color: 0xff0000,
        metalness: 0.8,
        roughness: 0.2
    });
    carBody = new THREE.Mesh(boxGeometry, boxMaterial);
    carBody.position.y = 0.5;
    car.add(carBody);

    // Add headlights
    [-0.6, 0.6].forEach(x => {
        const light = new THREE.SpotLight(0xffffee, 2, 100, Math.PI / 6, 0.5);
        light.position.set(x, 0.5, 2.3);
        light.target.position.set(x, 0, 50);
        car.add(light);
        car.add(light.target);
    });

    // Try to load the Porsche 911 GLB model
    const loader = new THREE.GLTFLoader();

    loader.load(
        'porsche_911_930_low_poly.glb',
        function (gltf) {
            const porscheModel = gltf.scene;

            // Remove fallback box before adding model
            car.remove(carBody);

            // Store reference to the model for body rotation
            carBody = porscheModel;

            // Rotate the model to face forward (positive Z direction)
            porscheModel.rotation.y = Math.PI / 2; // 90 degrees counter-clockwise (facing forward)

            // Scale the model to appropriate size
            const scale = 2.5;
            porscheModel.scale.set(scale, scale, scale);

            // Adjust the Y position so the car sits on the road
            porscheModel.position.y = -0.5;

            // Create environment map for reflections
            const envMapSize = 256;
            const envMapCanvas = document.createElement('canvas');
            envMapCanvas.width = envMapSize;
            envMapCanvas.height = envMapSize;
            const ctx = envMapCanvas.getContext('2d');

            // Sunrise gradient - warm eastern light
            const gradient = ctx.createLinearGradient(0, envMapSize, 0, 0);
            gradient.addColorStop(0, '#1a1a2a'); // Dark ground
            gradient.addColorStop(0.3, '#3a3a5a'); // Horizon
            gradient.addColorStop(0.5, '#ffaa66'); // Sunrise orange
            gradient.addColorStop(0.7, '#ffddaa'); // Bright sunrise
            gradient.addColorStop(1, '#aaccff');   // Sky blue
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, envMapSize, envMapSize);

            const envTexture = new THREE.CanvasTexture(envMapCanvas);
            envTexture.mapping = THREE.EquirectangularReflectionMapping;

            // Enhance materials for better lighting and reflections
            porscheModel.traverse((child) => {
                if (child.isMesh) {
                    if (child.material) {
                        // Lighten the color - multiply by 2.5x
                        if (child.material.color) {
                            const color = child.material.color;
                            color.r = Math.min(1, color.r * 2.5);
                            color.g = Math.min(1, color.g * 2.5);
                            color.b = Math.min(1, color.b * 2.5);
                        }

                        // Make materials highly reflective with environment map
                        child.material.metalness = 0.9;
                        child.material.roughness = 0.15;
                        child.material.envMap = envTexture;
                        child.material.envMapIntensity = 2.0;

                        // Add subtle emissive glow
                        if (!child.material.emissive) {
                            child.material.emissive = new THREE.Color(0x222222);
                        }
                        child.material.emissiveIntensity = 0.2;

                        // Ensure materials update
                        child.material.needsUpdate = true;
                    }
                }
            });

            car.add(porscheModel);

            // Add headlight beams
            const headlightPositions = [
                { x: -0.6, z: 2.5 },
                { x: 0.6, z: 2.5 }
            ];

            headlightPositions.forEach(pos => {
                const light = new THREE.SpotLight(0xffffee, 2, 100, Math.PI / 6, 0.5);
                light.position.set(pos.x, 0.5, pos.z);
                light.target.position.set(pos.x, 0, 50);
                car.add(light);
                car.add(light.target);
            });

            console.log('Porsche 911 model loaded successfully');
        },
        function (xhr) {
            console.log((xhr.loaded / xhr.total * 100) + '% loaded');
        },
        function (error) {
            console.log('Porsche model not available, using fallback box car');
            // Fallback box already created, just keep using it
        }
    );

    car.position.copy(carState.position);
    car.rotation.y = carState.rotation;
    scene.add(car);
}

function createStreetLights() {
    const lightSpacing = 50;
    const totalLights = Math.floor(roadCurve.getLength() / lightSpacing);
    
    for (let i = 0; i < totalLights; i++) {
        const t = i / totalLights;
        const point = roadCurve.getPointAt(t);
        const tangent = roadCurve.getTangentAt(t);
        const normal = new THREE.Vector3(-tangent.z, 0, tangent.x).normalize();
        
        // Alternate sides - position just outside road walls
        const side = i % 2 === 0 ? 1 : -1;
        const offset = normal.clone().multiplyScalar(side * 28); // Outside the 48m road
        
        createStreetLight(
            point.x + offset.x,
            point.z + offset.z,
            -side * Math.PI / 6
        );
    }
}

function createStreetLight(x, z, rotation) {
    const group = new THREE.Group();
    
    // Pole
    const poleGeometry = new THREE.CylinderGeometry(0.15, 0.2, 8, 8);
    const poleMaterial = new THREE.MeshStandardMaterial({ color: 0x333333 });
    const pole = new THREE.Mesh(poleGeometry, poleMaterial);
    pole.position.y = 4;
    group.add(pole);
    
    // Arm
    const armGeometry = new THREE.CylinderGeometry(0.08, 0.08, 4, 8);
    const arm = new THREE.Mesh(armGeometry, poleMaterial);
    arm.rotation.z = Math.PI / 2 - 0.3;
    arm.position.set(1.5, 7.5, 0);
    group.add(arm);
    
    // Light fixture
    const fixtureGeometry = new THREE.ConeGeometry(0.4, 0.6, 8);
    const fixtureMaterial = new THREE.MeshStandardMaterial({ color: 0x444444 });
    const fixture = new THREE.Mesh(fixtureGeometry, fixtureMaterial);
    fixture.position.set(3, 7, 0);
    fixture.rotation.z = Math.PI;
    group.add(fixture);
    
    // Light bulb (emissive)
    const bulbGeometry = new THREE.SphereGeometry(0.2, 8, 8);
    const bulbMaterial = new THREE.MeshBasicMaterial({ color: 0xffaa55 });
    const bulb = new THREE.Mesh(bulbGeometry, bulbMaterial);
    bulb.position.set(3, 6.7, 0);
    group.add(bulb);
    
    // Halo sprite
    const haloTexture = createHaloTexture();
    const haloMaterial = new THREE.SpriteMaterial({ 
        map: haloTexture,
        color: 0xffaa55,
        transparent: true,
        blending: THREE.AdditiveBlending
    });
    const halo = new THREE.Sprite(haloMaterial);
    halo.scale.set(8, 8, 1);
    halo.position.set(3, 6.7, 0);
    group.add(halo);
    
    // Ground light pool
    const poolGeometry = new THREE.CircleGeometry(6, 16);
    const poolMaterial = new THREE.MeshBasicMaterial({ 
        color: 0xffaa55,
        transparent: true,
        opacity: 0.1
    });
    const pool = new THREE.Mesh(poolGeometry, poolMaterial);
    pool.rotation.x = -Math.PI / 2;
    pool.position.set(3, 0.02, 0);
    group.add(pool);
    
    group.position.set(x, 0, z);
    group.rotation.y = rotation;
    group.scale.set(1.5, 1.5, 1.5); // 50% bigger
    scene.add(group);
    
    streetLights.push({
        group,
        bulb,
        halo,
        pool,
        baseIntensity: 1
    });
}

function createHaloTexture() {
    const canvas = document.createElement('canvas');
    canvas.width = 64;
    canvas.height = 64;
    const ctx = canvas.getContext('2d');
    
    const gradient = ctx.createRadialGradient(32, 32, 0, 32, 32, 32);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
    gradient.addColorStop(0.3, 'rgba(255, 200, 100, 0.5)');
    gradient.addColorStop(1, 'rgba(255, 150, 50, 0)');
    
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 64, 64);
    
    const texture = new THREE.CanvasTexture(canvas);
    return texture;
}

function createLake() {
    const lakeGeometry = new THREE.PlaneGeometry(8000, 20000);
    const lakeMaterial = new THREE.MeshStandardMaterial({
        color: 0x0a1a2a,
        metalness: 0.9,
        roughness: 0.1
    });
    const lake = new THREE.Mesh(lakeGeometry, lakeMaterial);
    lake.rotation.x = -Math.PI / 2;
    lake.position.set(-3000, -1, 0); // EAST side (negative X in our coord system)
    scene.add(lake);
}

function createCity() {
    // Create real buildings from GPS data
    console.log(`Creating ${BUILDINGS.length} real buildings along Lake Shore Drive`);

    BUILDINGS.forEach((data, index) => {
        // Create material with building-specific color
        const buildingMaterial = new THREE.MeshStandardMaterial({
            color: data.color,
            emissive: data.emissive,
            emissiveIntensity: 0.15,
            metalness: 0.3,
            roughness: 0.7
        });

        // Create geometry based on shape
        let buildingGeometry;
        switch(data.shape) {
            case "tapered":
                // John Hancock - tapered tower
                buildingGeometry = new THREE.ConeGeometry(data.width/2, data.height, 4);
                buildingGeometry.rotateY(Math.PI / 4);
                break;
            case "pyramid-top":
                // Two Prudential - box with pyramid top
                buildingGeometry = new THREE.BoxGeometry(data.width, data.height, data.depth);
                break;
            case "wavy":
            case "curved-clover":
                // Aqua Tower, Lake Point Tower - use cylinder for curved buildings
                buildingGeometry = new THREE.CylinderGeometry(data.width/2, data.width/2, data.height, 8);
                break;
            case "ferris-wheel":
                // Special case - will be created separately
                createNavyPierFerrisWheel(data);
                return;
            case "stadium":
                // Soldier Field - low and wide
                buildingGeometry = new THREE.BoxGeometry(data.width, data.height, data.depth);
                break;
            case "dome":
                // Adler Planetarium
                buildingGeometry = new THREE.SphereGeometry(data.width/2, 16, 16, 0, Math.PI * 2, 0, Math.PI / 2);
                break;
            case "neoclassical":
                // Museums - low classical buildings
                buildingGeometry = new THREE.BoxGeometry(data.width, data.height, data.depth);
                break;
            default:
                // Standard box
                buildingGeometry = new THREE.BoxGeometry(data.width, data.height, data.depth);
        }

        const building = new THREE.Mesh(buildingGeometry, buildingMaterial);

        // Calculate actual X position: road centerline X + offset
        // Negative offset = west/city side, Positive offset = east/lake side
        const roadX = getRoadXAtZ(data.z);
        const actualX = roadX + data.offset;

        // Position building
        building.position.set(
            actualX,
            data.shape === "dome" ? data.height/2 : data.height / 2,
            data.z  // Z matches car coordinate system
        );

        // Add lit windows for tall buildings
        if (data.height > 50 && data.shape !== "ferris-wheel" && data.shape !== "stadium" && data.shape !== "dome" && data.shape !== "neoclassical") {
            addWindowLights(building, data.width, data.height, data.depth);
        }

        // Store building data for reference
        building.userData.buildingName = data.name;
        building.userData.buildingType = data.type;

        scene.add(building);

        // Log landmark buildings
        if (data.type === "landmark") {
            console.log(`Created ${data.name} at (${actualX.toFixed(0)}, ${data.z.toFixed(0)}) - ${data.height}m tall`);
        }
    });
}

function addWindowLights(building, width, height, depth) {
    const windowGeometry = new THREE.PlaneGeometry(2, 3);
    const windowMaterial = new THREE.MeshBasicMaterial({
        color: 0xffeeaa,
        transparent: true,
        opacity: 0.8
    });
    
    const floors = Math.floor(height / 4);
    const windowsPerFloor = Math.floor(width / 5);
    
    for (let floor = 1; floor < floors; floor++) {
        for (let w = 0; w < windowsPerFloor; w++) {
            if (Math.random() > 0.3) continue; // Random lit windows
            
            const window = new THREE.Mesh(windowGeometry, windowMaterial);
            window.position.set(
                -width/2 + 2 + w * 5,
                -height/2 + floor * 4,
                depth/2 + 0.1
            );
            building.add(window);
        }
    }
}

function createNavyPierFerrisWheel(data) {
    // Navy Pier Ferris Wheel with real GPS position

    // Safety check - ensure data has required fields
    if (!data || typeof data.z === 'undefined' || typeof data.offset === 'undefined') {
        console.error('createNavyPierFerrisWheel: Invalid data', data);
        return;
    }

    const group = new THREE.Group();

    // Main wheel structure
    const wheelRadius = 30;
    const wheelGeometry = new THREE.TorusGeometry(wheelRadius, 0.5, 8, 64);
    const wheelMaterial = new THREE.MeshStandardMaterial({
        color: 0x444466,
        emissive: 0x2a2a4a,
        emissiveIntensity: 0.2
    });
    const wheel = new THREE.Mesh(wheelGeometry, wheelMaterial);
    wheel.rotation.x = Math.PI / 2;
    wheel.position.y = wheelRadius + 5;
    group.add(wheel);

    // Spokes
    for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const spokeGeometry = new THREE.CylinderGeometry(0.2, 0.2, wheelRadius * 2, 8);
        const spoke = new THREE.Mesh(spokeGeometry, wheelMaterial);
        spoke.rotation.z = angle;
        spoke.position.y = wheelRadius + 5;
        group.add(spoke);
    }

    // Support structure
    const supportGeometry = new THREE.CylinderGeometry(1, 2, wheelRadius + 5, 8);
    const support = new THREE.Mesh(supportGeometry, wheelMaterial);
    support.position.set(0, (wheelRadius + 5) / 2, -3);
    support.rotation.x = 0.1;
    group.add(support);

    const support2 = support.clone();
    support2.position.z = 3;
    support2.rotation.x = -0.1;
    group.add(support2);

    // LED lights around the rim - colorful!
    const ledCount = 72;
    for (let i = 0; i < ledCount; i++) {
        const angle = (i / ledCount) * Math.PI * 2;
        const ledGeometry = new THREE.SphereGeometry(0.5, 8, 8);
        const ledMaterial = new THREE.MeshBasicMaterial({
            color: new THREE.Color().setHSL(i / ledCount, 1, 0.5)
        });
        const led = new THREE.Mesh(ledGeometry, ledMaterial);
        led.position.set(
            Math.cos(angle) * wheelRadius,
            wheelRadius + 5 + Math.sin(angle) * wheelRadius,
            0
        );
        group.add(led);
    }

    // Position using offset from road centerline
    const roadX = getRoadXAtZ(data.z);
    const actualX = roadX + data.offset;

    // Additional safety check
    if (typeof actualX === 'undefined' || typeof data.z === 'undefined') {
        console.error('createNavyPierFerrisWheel: Position calculation failed', { roadX, actualX, z: data.z });
        return;
    }

    group.position.set(actualX, 0, data.z);
    scene.add(group);

    // Store for animation
    group.userData.wheel = wheel;
    group.userData.time = 0;
    group.userData.buildingName = data.name || "Navy Pier Ferris Wheel";
    window.ferrisWheel = group;

    console.log(`Created ${data.name} at (${actualX.toFixed(0)}, ${data.z.toFixed(0)})`);
}

function setupMinimap() {
    const canvas = document.getElementById('minimap-canvas');
    canvas.width = 180;
    canvas.height = 180;
}

function updateMinimap() {
    const canvas = document.getElementById('minimap-canvas');
    const ctx = canvas.getContext('2d');
    
    // Clear
    ctx.fillStyle = 'rgba(0, 20, 40, 0.9)';
    ctx.fillRect(0, 0, 180, 180);
    
    // Scale and center on car
    const scale = 0.008;
    const centerX = 90;
    const centerY = 90;
    
    // Draw road
    ctx.strokeStyle = '#444';
    ctx.lineWidth = 3;
    ctx.beginPath();
    
    for (let i = 0; i < LSD_CENTERLINE.length; i += 5) {
        const p = LSD_CENTERLINE[i];
        const x = centerX + (p.x - carState.position.x) * scale;
        const y = centerY + (-p.y - carState.position.z) * scale;
        
        if (i === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
    }
    ctx.stroke();
    
    // Draw car
    ctx.fillStyle = '#ff3333';
    ctx.save();
    ctx.translate(centerX, centerY);
    ctx.rotate(-carState.rotation + Math.PI);
    ctx.fillRect(-4, -6, 8, 12);
    ctx.restore();
    
    // Draw landmarks
    ctx.fillStyle = '#ffaa00';
    ctx.font = '8px sans-serif';
    LANDMARKS.forEach(lm => {
        const y = centerY + (lm.y - carState.position.z) * scale;
        if (y > 10 && y < 170) {
            ctx.fillRect(centerX - 40, y, 2, 2);
        }
    });
}

function initDriftTrail() {
    // Create a ribbon geometry for the trail
    const geometry = new THREE.BufferGeometry();
    
    // Pre-allocate positions (2 vertices per point - left and right edge)
    const positions = new Float32Array(maxTrailPoints * 2 * 3);
    const colors = new Float32Array(maxTrailPoints * 2 * 4);
    
    geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
    geometry.setAttribute('color', new THREE.BufferAttribute(colors, 4));
    
    const material = new THREE.MeshBasicMaterial({
        vertexColors: true,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false
    });
    
    driftTrail = new THREE.Mesh(geometry, material);
    driftTrail.frustumCulled = false;
    scene.add(driftTrail);
}

function updateDriftTrail(isDrifting, carPos, carRotation, visualDriftAngle) {
    if (!driftTrail) return;
    
    const trailWidth = 2.2; // Width of the car
    
    if (isDrifting && Math.abs(visualDriftAngle) > 0.1) {
        // Calculate rear of car position
        const totalRotation = carRotation + visualDriftAngle;
        const forward = new THREE.Vector3(Math.sin(totalRotation), 0, Math.cos(totalRotation));
        const right = new THREE.Vector3(Math.cos(totalRotation), 0, -Math.sin(totalRotation));
        
        const rearCenter = carPos.clone().sub(forward.multiplyScalar(2.5));
        const leftEdge = rearCenter.clone().add(right.clone().multiplyScalar(trailWidth / 2));
        const rightEdge = rearCenter.clone().sub(right.clone().multiplyScalar(trailWidth / 2));
        
        // Add new trail point
        trailPositions.push({
            left: leftEdge,
            right: rightEdge,
            age: 0
        });
        
        // Limit trail length
        while (trailPositions.length > maxTrailPoints) {
            trailPositions.shift();
        }
    }
    
    // Age and update trail geometry
    const positions = driftTrail.geometry.attributes.position.array;
    const colors = driftTrail.geometry.attributes.color.array;
    
    // Clear arrays
    positions.fill(0);
    colors.fill(0);
    
    for (let i = trailPositions.length - 1; i >= 0; i--) {
        const point = trailPositions[i];
        point.age += 0.016; // Approximate dt
        
        // Remove old points
        if (point.age > 2.0) {
            trailPositions.splice(i, 1);
            continue;
        }
        
        const idx = i * 2;
        const posIdx = idx * 3;
        const colIdx = idx * 4;
        
        // Set positions (flat on ground)
        positions[posIdx] = point.left.x;
        positions[posIdx + 1] = 0.05; // Just above ground
        positions[posIdx + 2] = point.left.z;
        
        positions[posIdx + 3] = point.right.x;
        positions[posIdx + 4] = 0.05;
        positions[posIdx + 5] = point.right.z;
        
        // Neon green color with fade based on age
        const alpha = Math.max(0, 1 - point.age / 2.0);
        const glow = 0.8 + Math.sin(point.age * 10) * 0.2; // Subtle pulse
        
        // Left vertex - neon green
        colors[colIdx] = 0.2 * glow;      // R
        colors[colIdx + 1] = 1.0 * glow;  // G
        colors[colIdx + 2] = 0.4 * glow;  // B
        colors[colIdx + 3] = alpha;        // A
        
        // Right vertex - neon green
        colors[colIdx + 4] = 0.2 * glow;
        colors[colIdx + 5] = 1.0 * glow;
        colors[colIdx + 6] = 0.4 * glow;
        colors[colIdx + 7] = alpha;
    }
    
    driftTrail.geometry.attributes.position.needsUpdate = true;
    driftTrail.geometry.attributes.color.needsUpdate = true;
    
    // Rebuild index for triangle strip
    if (trailPositions.length > 1) {
        const indices = [];
        for (let i = 0; i < trailPositions.length - 1; i++) {
            const idx = i * 2;
            indices.push(idx, idx + 1, idx + 2);
            indices.push(idx + 1, idx + 3, idx + 2);
        }
        driftTrail.geometry.setIndex(indices);
    }
}

function updatePhysics(dt) {
    // Input
    let throttle = 0;
    let steering = 0;
    let handbrake = false;
    let drifting = false;
    
    if (keys['KeyW'] || keys['ArrowUp']) throttle = 1;
    if (keys['KeyS'] || keys['ArrowDown']) throttle = -1;
    if (keys['KeyA'] || keys['ArrowLeft']) steering = 1;
    if (keys['KeyD'] || keys['ArrowRight']) steering = -1;
    if (keys['Space']) handbrake = true;
    if (keys['ShiftLeft'] || keys['ShiftRight']) drifting = true;

    // HYPERDRIVE MODE - Press H for ultra-fast building viewing
    const hyperdrive = keys['KeyH'];
    const hyperMultiplier = hyperdrive ? 10.0 : 1.0;

    // Boost (now on E key) - DRAMATIC
    const boosting = keys['KeyE'];
    if (boosting && carState.boost > 0 && throttle > 0) {
        carState.isBoosting = true;
        carState.boost = Math.max(0, carState.boost - dt * 20);
        throttle *= 3.5; // Much more dramatic boost
    } else {
        carState.isBoosting = false;
        carState.boost = Math.min(100, carState.boost + dt * 12);
    }

    // Apply hyperdrive multiplier to throttle
    throttle *= hyperMultiplier;

    // Physics constants - ARCADE INSANE
    const maxSpeed = 306 * hyperMultiplier; // m/s (~680 mph) - 2x previous, 10x in hyperdrive
    const acceleration = 204 * hyperMultiplier; // 2x previous, 10x in hyperdrive
    const braking = 170;
    const turnSpeed = 1.05;
    const drag = hyperdrive ? 0.999 : 0.988; // Less drag in hyperdrive
    
    // Drift mechanics - Shift triggers drift without losing speed
    const normalGrip = 0.92;
    const driftGrip = 0.15;  // Very low grip when drifting - car slides more
    const isDrifting = drifting && Math.abs(steering) > 0.1 && Math.abs(carState.speed) > 20;
    const grip = isDrifting ? driftGrip : (handbrake ? 0.5 : normalGrip);
    
    // Track drift state
    if (!carState.driftAngle) carState.driftAngle = 0;
    if (!carState.visualDriftAngle) carState.visualDriftAngle = 0;
    if (!carState.isDrifting) carState.isDrifting = false;
    carState.isDrifting = isDrifting;
    
    // Current speed
    const forward = new THREE.Vector3(
        Math.sin(carState.rotation),
        0,
        Math.cos(carState.rotation)
    );
    
    const right = new THREE.Vector3(
        Math.cos(carState.rotation),
        0,
        -Math.sin(carState.rotation)
    );
    
    carState.speed = carState.velocity.dot(forward);
    const speedRatio = Math.abs(carState.speed) / maxSpeed;
    
    // Acceleration, braking, and reverse
    if (throttle !== 0) {
        if (throttle > 0) {
            // Accelerate forward
            const accelMultiplier = Math.pow(1 - Math.max(0, speedRatio), 1.5);
            const accel = forward.clone().multiplyScalar(throttle * acceleration * accelMultiplier * dt);
            carState.velocity.add(accel);
        } else if (throttle < 0) {
            if (carState.speed > 5) {
                // Brake when moving forward at decent speed
                const accel = forward.clone().multiplyScalar(throttle * braking * 2 * dt);
                carState.velocity.add(accel);
            } else {
                // Reverse mode
                // Kill any forward velocity completely
                if (carState.speed > 0) {
                    carState.velocity.set(0, 0, 0);
                }
                
                // Apply strong reverse force
                const reverseMaxSpeed = 80;
                const currentReverseSpeed = -carState.speed; // positive number when going backward
                
                if (currentReverseSpeed < reverseMaxSpeed) {
                    // Direct velocity set for more reliable reverse
                    const reverseAccel = 120 * dt;
                    const newSpeed = Math.min(currentReverseSpeed + reverseAccel, reverseMaxSpeed);
                    carState.velocity.copy(forward.clone().multiplyScalar(-newSpeed));
                }
            }
        }
    }
    
    // Steering - SLOWER turn rate during drift for wide satisfying slides
    if (Math.abs(carState.speed) > 0.5) {
        const baseTurnMultiplier = 1 - speedRatio * 0.5;
        // Drift = slower actual turning (0.4x) for wide arcs
        const driftTurnRate = isDrifting ? 0.4 : 1.0;
        const turn = steering * turnSpeed * driftTurnRate * Math.sign(carState.speed) * dt * baseTurnMultiplier;
        carState.rotation += turn;
        
        // Calculate actual drift angle (difference between velocity direction and car heading)
        const velocityAngle = Math.atan2(carState.velocity.x, carState.velocity.z);
        carState.driftAngle = carState.rotation - velocityAngle;
        
        // Normalize drift angle
        while (carState.driftAngle > Math.PI) carState.driftAngle -= Math.PI * 2;
        while (carState.driftAngle < -Math.PI) carState.driftAngle += Math.PI * 2;
        
        // VISUAL drift angle - this is the dramatic 45° rotation
        // Smoothly lerp towards target visual angle
        const targetVisualAngle = isDrifting ? (steering * 0.75) : 0;  // ~45 degrees (0.75 rad) max
        carState.visualDriftAngle += (targetVisualAngle - carState.visualDriftAngle) * dt * 5;
        
        // Rotate velocity towards heading (slower when drifting = more slide)
        // Only apply when going forward - don't fight reverse!
        if (carState.speed > 0) {
            const currentDir = carState.velocity.clone().normalize();
            const targetDir = forward.clone();
            currentDir.lerp(targetDir, grip);
            carState.velocity.copy(currentDir.multiplyScalar(carState.velocity.length()));
        }
    } else {
        carState.driftAngle = 0;
        carState.visualDriftAngle *= 0.9; // Fade out visual angle when stopped
    }
    
    // Drag (minimal penalty during drift - keep the speed!)
    const driftDrag = handbrake ? 0.98 : drag;
    carState.velocity.multiplyScalar(driftDrag);
    
    // Snap to zero when nearly stopped (fixes reverse not engaging)
    if (carState.velocity.length() < 2) {
        carState.velocity.set(0, 0, 0);
    }
    
    // Initialize airborne state if needed
    if (carState.verticalVelocity === undefined) carState.verticalVelocity = 0;
    if (carState.airborne === undefined) carState.airborne = false;
    if (carState.groundY === undefined) carState.groundY = 0.5;
    
    // Update horizontal position
    carState.position.add(carState.velocity.clone().multiplyScalar(dt));
    
    // Check for jump ramps
    let onRamp = false;
    let rampHeight = 0;
    
    if (window.jumps && window.jumps.length > 0) {
        for (const jump of window.jumps) {
            // Vector from jump center to car (only horizontal)
            const tocar = new THREE.Vector3(
                carState.position.x - jump.position.x,
                0,
                carState.position.z - jump.position.z
            );
            
            // Simple distance check first - if too far, skip
            const dist = tocar.length();
            if (dist > jump.length) continue;
            
            // Project onto jump's local axes
            const alongJump = tocar.dot(jump.tangent);
            const acrossJump = tocar.dot(jump.normal);
            
            // Check if car is on this jump - more forgiving detection
            const onLength = Math.abs(alongJump) < jump.length / 2 + 2;
            const onWidth = Math.abs(acrossJump) < jump.width / 2 + 2;
            
            if (onLength && onWidth) {
                onRamp = true;
                
                // Calculate height based on position along ramp
                const rampProgress = Math.max(0, Math.min(1, (alongJump + jump.length / 2) / jump.length));
                rampHeight = rampProgress * jump.height;
                
                // If at the end of ramp and going fast, launch!
                if (rampProgress > 0.8 && Math.abs(carState.speed) > 10 && !carState.airborne) {
                    carState.airborne = true;
                    // Launch velocity based on speed and ramp angle
                    carState.verticalVelocity = Math.abs(carState.speed) * 0.10 + 6;
                }
            }
        }
    }
    
    // Airborne physics
    const gravity = 25;
    
    if (carState.airborne) {
        // Apply gravity
        carState.verticalVelocity -= gravity * dt;
        carState.position.y += carState.verticalVelocity * dt;
        
        // Check for landing
        const groundLevel = onRamp ? rampHeight + 0.5 : 0.5;
        if (carState.position.y <= groundLevel) {
            carState.position.y = groundLevel;
            carState.airborne = false;
            carState.verticalVelocity = 0;
        }
    } else if (onRamp) {
        // On ramp but not airborne - follow ramp surface
        carState.position.y = rampHeight + 0.5;
    } else {
        // On ground
        carState.position.y = 0.5;
    }
    
    // Wall collision detection - DISABLED FOR FREE WORLD MODE
    // if (window.wallSegments && window.wallSegments.length > 0) {
    //     // Find nearest wall segment
    //     let nearestDist = Infinity;
    //     let nearestSegment = null;
    //
    //     for (const seg of window.wallSegments) {
    //         const dist = carState.position.distanceTo(seg.center);
    //         if (dist < nearestDist) {
    //             nearestDist = dist;
    //             nearestSegment = seg;
    //         }
    //     }
    //
    //     if (nearestSegment) {
    //         // Calculate distance from road center along the normal
    //         const tocar = carState.position.clone().sub(nearestSegment.center);
    //         const lateralDist = tocar.dot(nearestSegment.normal);
    //         const halfRoad = nearestSegment.roadWidth / 2 - 1; // Keep car 1m from actual wall
    //
    //         // If outside road bounds, slide along wall
    //         if (Math.abs(lateralDist) > halfRoad) {
    //             // Push car back to road edge
    //             const wallSide = Math.sign(lateralDist);
    //             const correction = nearestSegment.normal.clone().multiplyScalar(wallSide * halfRoad - lateralDist);
    //             carState.position.add(correction);
    //
    //             // Remove only the velocity component going into the wall
    //             const normalVel = carState.velocity.dot(nearestSegment.normal);
    //             if ((wallSide > 0 && normalVel > 0) || (wallSide < 0 && normalVel < 0)) {
    //                 // Just zero out the into-wall velocity, keep the along-wall velocity
    //                 carState.velocity.sub(nearestSegment.normal.clone().multiplyScalar(normalVel));
    //             }
    //         }
    //     }
    // }
    
    // Update car mesh - use VISUAL drift angle for dramatic rotation
    car.position.copy(carState.position);
    car.rotation.y = carState.rotation + carState.visualDriftAngle;
    
    // Tilt car based on drift and airborne state
    const driftTilt = carState.visualDriftAngle * 0.12;
    carBody.rotation.z = driftTilt;
    
    // Pitch forward/back when airborne based on vertical velocity
    if (carState.airborne) {
        const pitchAmount = -carState.verticalVelocity * 0.015;
        carBody.rotation.x = Math.max(-0.4, Math.min(0.4, pitchAmount));
    } else {
        carBody.rotation.x *= 0.8; // Smoothly return to level
    }
    
    // Update drift trail
    updateDriftTrail(isDrifting, carState.position, carState.rotation, carState.visualDriftAngle);
}

function updateCamera() {
    const mode = cameraModes[cameraMode];
    const forward = new THREE.Vector3(
        Math.sin(carState.rotation),
        0,
        Math.cos(carState.rotation)
    );
    
    // Dynamic FOV - wider when boosting for speed effect
    const baseFOV = 75;
    const boostFOV = 95;
    const targetFOV = carState.isBoosting ? boostFOV : baseFOV;
    camera.fov += (targetFOV - camera.fov) * 0.1;
    camera.updateProjectionMatrix();
    
    if (mode === 'chase') {
        // Calculate target position: close behind and above the car
        // Pull camera back more when boosting
        const boostPullback = carState.isBoosting ? 8 : 5;
        const targetPos = carState.position.clone()
            .sub(forward.clone().multiplyScalar(boostPullback))
            .add(new THREE.Vector3(0, 2, 0));
        
        // Smooth follow - moderate catch-up when slowing, not too aggressive
        const speedFactor = Math.abs(carState.speed) / 150; // 0 to ~1 at high speed
        const smoothing = 0.10 + (1 - Math.min(speedFactor, 1)) * 0.12; // 0.10 at speed, up to 0.22 when slow
        camera.position.x += (targetPos.x - camera.position.x) * smoothing;
        camera.position.y += (targetPos.y - camera.position.y) * smoothing;
        camera.position.z += (targetPos.z - camera.position.z) * smoothing;
        
        // Keep camera above ground
        camera.position.y = Math.max(camera.position.y, 1.5);
        
        // CLAMP: Don't let camera get more than maxDist from target
        const maxDist = carState.isBoosting ? 8 : 5;
        const offset = camera.position.clone().sub(targetPos);
        if (offset.length() > maxDist) {
            offset.setLength(maxDist);
            camera.position.copy(targetPos.clone().add(offset));
        }
        
        // Look at a point ahead of the car (directly, no smoothing that can flip)
        const lookTarget = carState.position.clone().add(forward.clone().multiplyScalar(10));
        lookTarget.y = carState.position.y + 0.5; // Look slightly above car level
        camera.lookAt(lookTarget);
    } else if (mode === 'hood') {
        camera.position.copy(carState.position)
            .add(new THREE.Vector3(0, 1.5, 0))
            .add(forward.clone().multiplyScalar(1));
        camera.lookAt(carState.position.clone().add(forward.multiplyScalar(50)));
    } else if (mode === 'cinematic') {
        // Fixed drone shot - high above and behind
        const targetPos = carState.position.clone()
            .sub(forward.clone().multiplyScalar(15))
            .add(new THREE.Vector3(0, 12, 0));
        
        camera.position.lerp(targetPos, 0.08);
        camera.lookAt(carState.position);
    }
}

function updateHUD() {
    const mph = Math.abs(carState.speed * 0.79).toFixed(0); // Scaled to max ~125 mph
    document.getElementById('speed-value').textContent = mph;
    document.getElementById('boost-fill').style.width = carState.boost + '%';

    // Hyperdrive indicator
    const hyperdriveEl = document.getElementById('hyperdrive-indicator');
    if (keys['KeyH']) {
        hyperdriveEl.style.display = 'block';
    } else {
        hyperdriveEl.style.display = 'none';
    }

    // Progress
    const progress = (carState.position.z + 8000) / 16000 * 100;
    document.getElementById('progress-fill').style.width = Math.max(0, Math.min(100, progress)) + '%';

    // Landmark detection
    const currentY = -carState.position.z;
    for (const lm of LANDMARKS) {
        if (Math.abs(currentY - lm.y) < 100) {
            const el = document.getElementById('landmark');
            if (el.textContent !== lm.name) {
                el.textContent = lm.name;
                el.classList.add('visible');
                setTimeout(() => el.classList.remove('visible'), 3000);
            }
            break;
        }
    }
}

function toggleNight() {
    isNight = !isNight;
    
    if (isNight) {
        scene.background = new THREE.Color(0x0a0a15);
        scene.fog = new THREE.FogExp2(0x0a0a15, 0.00015);
    } else {
        scene.background = new THREE.Color(0x87ceeb);
        scene.fog = new THREE.FogExp2(0x87ceeb, 0.00008);
    }
    
    // Update street light visibility
    streetLights.forEach(light => {
        light.halo.visible = isNight;
        light.pool.visible = isNight;
    });
}

function toggleMusic() {
    if (window.backgroundMusic) {
        if (window.backgroundMusic.paused) {
            window.backgroundMusic.play();
        } else {
            window.backgroundMusic.pause();
        }
    }
}

function startCountdown() {
    raceState.countdown = 3;
    raceState.frozen = true;
    raceState.started = false;
    raceState.finished = false;
    
    const asciiNumbers = {
        3: `██████╗ 
╚════██╗
 █████╔╝
 ╚═══██╗
██████╔╝
╚═════╝ `,
        2: `██████╗ 
╚════██╗
 █████╔╝
██╔═══╝ 
███████╗
╚══════╝`,
        1: ` ██╗
███║
╚██║
 ██║
 ██║
 ╚═╝`,
        go: ` ██████╗  ██████╗ ██╗
██╔════╝ ██╔═══██╗██║
██║  ███╗██║   ██║██║
██║   ██║██║   ██║╚═╝
╚██████╔╝╚██████╔╝██╗
 ╚═════╝  ╚═════╝ ╚═╝`
    };
    
    const countdownEl = document.getElementById('countdown-text');
    const overlayEl = document.getElementById('countdown-overlay');
    overlayEl.style.display = 'flex';
    countdownEl.classList.remove('go');
    countdownEl.textContent = asciiNumbers[3];
    
    const countdownInterval = setInterval(() => {
        raceState.countdown--;
        
        if (raceState.countdown > 0) {
            countdownEl.textContent = asciiNumbers[raceState.countdown];
            countdownEl.style.animation = 'none';
            countdownEl.offsetHeight; // Trigger reflow
            countdownEl.style.animation = 'countdown-enter 0.3s ease-out';
        } else if (raceState.countdown === 0) {
            countdownEl.textContent = asciiNumbers.go;
            countdownEl.style.animation = 'none';
            countdownEl.offsetHeight;
            countdownEl.style.animation = 'countdown-enter 0.3s ease-out';
            
            // Start the race!
            raceState.frozen = false;
            raceState.started = true;
            raceState.startTime = performance.now();
        } else {
            // Hide overlay
            clearInterval(countdownInterval);
            overlayEl.style.display = 'none';
            countdownEl.classList.remove('go');
            countdownEl.textContent = '3';
        }
    }, 1000);
}

function formatTime(ms) {
    const totalSeconds = ms / 1000;
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = Math.floor(totalSeconds % 60);
    const centiseconds = Math.floor((ms % 1000) / 10);
    return `${minutes}:${seconds.toString().padStart(2, '0')}.${centiseconds.toString().padStart(2, '0')}`;
}

function updateRaceTimer() {
    if (raceState.started && !raceState.finished) {
        raceState.currentTime = performance.now() - raceState.startTime;
        document.getElementById('timer-value').textContent = formatTime(raceState.currentTime);
    }
    
    // Check for finish line crossing
    if (raceState.started && !raceState.finished && window.finishLine) {
        const toFinish = carState.position.clone().sub(window.finishLine.position);
        const distAlongTrack = toFinish.dot(window.finishLine.tangent);
        const distAcross = Math.sqrt(toFinish.lengthSq() - distAlongTrack * distAlongTrack);
        
        // If we're past the finish line and close to it
        if (distAlongTrack > 0 && distAlongTrack < 20 && distAcross < 30) {
            raceState.finished = true;
            
            // Check for best time
            const finishMsg = document.getElementById('finish-message');
            if (!raceState.bestTime || raceState.currentTime < raceState.bestTime) {
                raceState.bestTime = raceState.currentTime;
                document.getElementById('best-time').textContent = `Best: ${formatTime(raceState.bestTime)}`;
                finishMsg.innerHTML = `FINISH!<br><span style="font-size: 36px; color: #ffcc00;">NEW BEST TIME!</span><br>${formatTime(raceState.currentTime)}`;
            } else {
                finishMsg.innerHTML = `FINISH!<br>${formatTime(raceState.currentTime)}`;
            }
            finishMsg.style.display = 'block';
            
            // Hide finish message after 5 seconds and allow restart
            setTimeout(() => {
                finishMsg.style.display = 'none';
            }, 5000);
        }
    }
}

function resetRace() {
    // Reset car position to start
    carState.position.set(LSD_CENTERLINE[0].x, 0.5, -LSD_CENTERLINE[0].y);
    carState.velocity.set(0, 0, 0);
    carState.rotation = Math.PI;
    carState.speed = 0;
    carState.boost = 100;
    
    // Reset race state
    raceState.finished = false;
    document.getElementById('finish-message').style.display = 'none';
    
    // Start new countdown
    startCountdown();
}

// Debug visualization for road alignment
let debugGroup = null;

function createDebugVisualization() {
    debugGroup = new THREE.Group();
    debugGroup.visible = false; // Hidden by default, press V to toggle

    // Draw the road centerline path
    const centerlinePoints = LSD_CENTERLINE.map(p => new THREE.Vector3(p.x, 0.2, -p.y));
    const centerlineGeometry = new THREE.BufferGeometry().setFromPoints(centerlinePoints);
    const centerlineMaterial = new THREE.LineBasicMaterial({ color: 0xff0000, linewidth: 3 });
    const centerlineLine = new THREE.Line(centerlineGeometry, centerlineMaterial);
    debugGroup.add(centerlineLine);

    // Add coordinate grid markers every 1000 units
    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ff00 });
    for (let i = 0; i < LSD_CENTERLINE.length; i += 50) {
        const p = LSD_CENTERLINE[i];
        const marker = new THREE.Mesh(
            new THREE.SphereGeometry(5, 8, 8),
            markerMaterial
        );
        marker.position.set(p.x, 1, -p.y);
        debugGroup.add(marker);
    }

    // Add west/east markers to show which side is which
    const westMarkerGeometry = new THREE.BoxGeometry(50, 10, 50);
    const westMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0xff00ff, transparent: true, opacity: 0.5 });
    const westMarker = new THREE.Mesh(westMarkerGeometry, westMarkerMaterial);
    westMarker.position.set(getRoadXAtZ(0) - 300, 20, 0); // 300 units west
    debugGroup.add(westMarker);

    const eastMarkerGeometry = new THREE.BoxGeometry(50, 10, 50);
    const eastMarkerMaterial = new THREE.MeshBasicMaterial({ color: 0x00ffff, transparent: true, opacity: 0.5 });
    const eastMarker = new THREE.Mesh(eastMarkerGeometry, eastMarkerMaterial);
    eastMarker.position.set(getRoadXAtZ(0) + 300, 20, 0); // 300 units east
    debugGroup.add(eastMarker);

    scene.add(debugGroup);
    console.log('Debug visualization created. Press V to toggle visibility.');
}

function toggleDebugVisualization() {
    if (debugGroup) {
        debugGroup.visible = !debugGroup.visible;
        console.log('Debug visualization:', debugGroup.visible ? 'ON' : 'OFF');
        console.log('Red line = Road centerline, Green spheres = Every 50th centerline point');
        console.log('Magenta box = WEST (city side), Cyan box = EAST (lake side)');
    }
}

function animate() {
    requestAnimationFrame(animate);

    const now = performance.now();
    let dt = (now - lastTime) / 1000;
    lastTime = now;

    // Cap delta time to prevent physics explosions after tab switch or lag spike
    dt = Math.min(dt, 1/30);

    // Debug logging on first frame
    if (frameCount === 0) {
        console.log('=== FIRST FRAME RENDER ===');
        console.log('Car position:', car.position.x.toFixed(1), car.position.y.toFixed(1), car.position.z.toFixed(1));
        console.log('Camera position:', camera.position.x.toFixed(1), camera.position.y.toFixed(1), camera.position.z.toFixed(1));
        console.log('Scene children:', scene.children.length);
        console.log('Renderer size:', renderer.domElement.width, 'x', renderer.domElement.height);
    }

    // Debug logging every second
    if (now - lastDebugTime > 1000) {
        console.log(`Frame ${frameCount} - Car: (${car.position.x.toFixed(0)}, ${car.position.y.toFixed(1)}, ${car.position.z.toFixed(0)}) Camera: (${camera.position.x.toFixed(0)}, ${camera.position.y.toFixed(1)}, ${camera.position.z.toFixed(0)}) Speed: ${carState.speed.toFixed(1)}`);
        lastDebugTime = now;
    }

    frameCount++;

    // Only update physics if not frozen (countdown)
    if (!raceState.frozen) {
        updatePhysics(dt);
    }

    updateCamera();
    updateHUD();
    updateMinimap();
    updateEngineSound();
    updateRaceTimer();

    // Animate ferris wheel
    if (window.ferrisWheel) {
        window.ferrisWheel.userData.time += dt;
        // Slowly rotate
        window.ferrisWheel.children.forEach((child, i) => {
            if (child.geometry && child.geometry.type === 'TorusGeometry') {
                child.rotation.z += dt * 0.1;
            }
        });
    }

    renderer.render(scene, camera);
}

function onResize() {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
}
    </script>
</body>
</html>
